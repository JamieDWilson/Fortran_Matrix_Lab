var tipuesearch = {"pages":[{"title":" Fortran Matrix Lab ","text":"Fortran Matrix Lab Note Used in Wilson et al., (2019) Sensitivity of atmospheric CO _2 to regional variability in particulate organic matter remineralization depths. Biogeosciences. 16 (14) pp. 2923 -- 2936 Bug netCDF output is currently not producing 3-D goereferenced output that can be read by panoply. (The netCDF output can be read into matlab though) Developer Info Jamie D. Wilson School of Earth Sciences, University of Bristol, UK","tags":"home","loc":"index.html"},{"title":"io_module.f90 – Fortran Matrix Lab","text":"This file depends on sourcefile~~io_module.f90~~EfferentGraph sourcefile~io_module.f90 io_module.f90 sourcefile~fml_lib.f90 fml_lib.f90 sourcefile~io_module.f90->sourcefile~fml_lib.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~io_module.f90~~AfferentGraph sourcefile~io_module.f90 io_module.f90 sourcefile~tm_module.f90 tm_module.f90 sourcefile~tm_module.f90->sourcefile~io_module.f90 sourcefile~fml.f90 fml.f90 sourcefile~fml.f90->sourcefile~io_module.f90 sourcefile~fml.f90->sourcefile~tm_module.f90 sourcefile~bg_module.f90 bg_module.f90 sourcefile~fml.f90->sourcefile~bg_module.f90 sourcefile~bg_module.f90->sourcefile~tm_module.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules io_module Source Code io_module.f90 Source Code module io_module ! ---------------------------------------------------------------------------------------! !! Subroutines to load and write data ! ---------------------------------------------------------------------------------------! use fml_lib use netcdf implicit none contains ! ---------------------------------------------------------------------------------------! ! ---------------------------------------------------------------------------------------! subroutine load_TM_data () ! ---------------------------------------------------------------------------------------! !! OLD: Load transport matrix data from file ! ---------------------------------------------------------------------------------------! call load_TM_netcdf ( '../data' // '/' // trim ( tm_data_fileloc ) // '/' // trim ( tm_Aexp_filename ), Aexp ) call load_TM_netcdf ( '../data' // '/' // trim ( tm_data_fileloc ) // '/' // trim ( tm_Aimp_filename ), Aimp ) !call load_TM_netcdf(tm_Aremin_filename,Aremin) !Aremin%val=Aremin%val_n(:,1) ! tmp call load_TM_grid_data () call load_TM_bgc_data () select case ( trim ( bg_uptake_function )) case ( 'restore' ) call load_PO4_restore () case ( 'fixed' ) call load_PO4_uptake () end select if ( bg_martin_remin_spatial ) then call load_Martin_b_spatial () else bg_martin_b (:) = bg_martin_remin_b ! set global value to whole grid endif end subroutine load_TM_data ! ---------------------------------------------------------------------------------------! ! ---------------------------------------------------------------------------------------! SUBROUTINE load_TM_netcdf ( dum_filename , dum_A ) ! ---------------------------------------------------------------------------------------! !! Loads transport matrix data from netCDF files ! ---------------------------------------------------------------------------------------! character ( len =* ) :: dum_filename !! netCDF filename type ( sparse ) :: dum_A !! sparse matrix arrays integer :: loc_ncid , loc_varid , status character ( len = 100 ) :: loc_lname print * , 'loading TM data from:' , trim ( dum_filename ) ! open netcdf file status = nf90_open ( trim ( dum_filename ), nf90_nowrite , loc_ncid ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )), dum_filename ! matrix values status = nf90_inq_varid ( loc_ncid , 'A_val' , loc_varid ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )), 'A_val' status = nf90_get_var ( loc_ncid , loc_varid , dum_A % val_n ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )), 'A_val' !print*,dum_A%val_n(1:10,1) ! matrix column indices status = nf90_inq_varid ( loc_ncid , 'A_col' , loc_varid ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )), 'A_col' status = nf90_get_var ( loc_ncid , loc_varid , dum_A % col ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )), 'A_col' !print*,dum_A%col(1:20) ! matrix row pointer indices STATUS = nf90_inq_varid ( loc_ncid , 'A_row' , loc_varid ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )), 'A_row' status = nf90_get_var ( loc_ncid , loc_varid , dum_A % row ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )), 'A_row' !print*,dum_A%row(1:20) ! close netcdf file status = nf90_close ( loc_ncid ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) end subroutine load_TM_netcdf ! ---------------------------------------------------------------------------------------! ! ---------------------------------------------------------------------------------------! SUBROUTINE load_TM_metadata ( dum_filename , dum_A ) ! ---------------------------------------------------------------------------------------! !! Loads transport matrix metadata from netCDF file ! ---------------------------------------------------------------------------------------! character ( len =* ) :: dum_filename !! netCDF filename type ( sparse ) :: dum_A !! sparse matrix arrays integer :: loc_ncid , loc_varid , status character ( len = 100 ) :: loc_lname ! open netcdf file status = nf90_open ( trim ( dum_filename ), nf90_nowrite , loc_ncid ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )), dum_filename ! nonzeros status = nf90_inq_varid ( loc_ncid , 'nnz' , loc_varid ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )), 'nnz' status = nf90_get_var ( loc_ncid , loc_varid , dum_A % nnz ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )), 'nnz' !print*,dum_A%nnz ! nonzeros status = nf90_inq_varid ( loc_ncid , 'nb' , loc_varid ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )), 'nb' status = nf90_get_var ( loc_ncid , loc_varid , dum_A % nb ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )), 'nb' !print*,dum_A%nb ! nonzeros status = nf90_inq_varid ( loc_ncid , 'n_season' , loc_varid ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )), 'n_time' status = nf90_get_var ( loc_ncid , loc_varid , dum_A % n_time ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )), 'n_time' !print*,dum_A%n_time ! close netcdf file status = nf90_close ( loc_ncid ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) end subroutine load_TM_metadata ! ---------------------------------------------------------------------------------------! ! ---------------------------------------------------------------------------------------! subroutine load_TM_grid_data () ! ---------------------------------------------------------------------------------------! !! Loads transport matrix grid data from netCDF file ! ---------------------------------------------------------------------------------------! ! local variables integer :: n , status , loc_varid , loc_ncid ! open netcdf file status = nf90_open ( '../data/' // trim ( tm_data_fileloc ) // '/' // trim ( tm_grid_data_filename ) , nf90_nowrite , loc_ncid ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) // '->' // tm_grid_data_filename ! volume status = nf90_inq_varid ( loc_ncid , 'volume' , loc_varid ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) // '-> volume' status = nf90_get_var ( loc_ncid , loc_varid , tm_vol ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) // '-> volume' ! area status = nf90_inq_varid ( loc_ncid , 'area' , loc_varid ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) // '-> area' status = nf90_get_var ( loc_ncid , loc_varid , tm_area ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) // '-> area' ! longitude status = nf90_inq_varid ( loc_ncid , 'Longitude' , loc_varid ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) // '-> longitude' status = nf90_get_var ( loc_ncid , loc_varid , tm_lon ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) // '->longitude' ! latitude status = nf90_inq_varid ( loc_ncid , 'Latitude' , loc_varid ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) // '-> latitude' status = nf90_get_var ( loc_ncid , loc_varid , tm_lat ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) // '-> latitude' ! depth status = nf90_inq_varid ( loc_ncid , 'Depth' , loc_varid ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) // '-> depth' status = nf90_get_var ( loc_ncid , loc_varid , tm_depth ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) // '-> depth' ! bottom depth status = nf90_inq_varid ( loc_ncid , 'Depth_Btm' , loc_varid ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) // '-> depth_btm' status = nf90_get_var ( loc_ncid , loc_varid , tm_depth_btm ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) // '-> depth_btm' ! i status = nf90_inq_varid ( loc_ncid , 'i' , loc_varid ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) // '-> i' status = nf90_get_var ( loc_ncid , loc_varid , tm_i ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) // '-> i' ! j status = nf90_inq_varid ( loc_ncid , 'j' , loc_varid ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) // '-> j' status = nf90_get_var ( loc_ncid , loc_varid , tm_j ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) // '-> j' ! k status = nf90_inq_varid ( loc_ncid , 'k' , loc_varid ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) // '-> k' status = nf90_get_var ( loc_ncid , loc_varid , tm_k ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) // '-> k' ! close netcdf file status = nf90_close ( loc_ncid ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) end subroutine load_TM_grid_data ! ---------------------------------------------------------------------------------------! ! ---------------------------------------------------------------------------------------! subroutine load_TM_bgc_data () ! ---------------------------------------------------------------------------------------! !! Loads transport matrix biogeochemistry data from netCDF file ! ---------------------------------------------------------------------------------------! ! local variables integer :: n , status , loc_varid , loc_ncid ! open netcdf file status = nf90_open ( '../data/' // trim ( tm_data_fileloc ) // '/' // trim ( tm_bgc_data_filename ) , nf90_nowrite , loc_ncid ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) // '->' // tm_bgc_data_filename ! windspeed status = nf90_inq_varid ( loc_ncid , 'windspeed' , loc_varid ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) // '-> windspeed' status = nf90_get_var ( loc_ncid , loc_varid , tm_windspeed , start = ( / 1 , 1 / ), count = ( / n_euphotic_boxes , 12 / )) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) // '-> windspeed' ! seaice fraction status = nf90_inq_varid ( loc_ncid , 'Fice' , loc_varid ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) // '-> Fice' status = nf90_get_var ( loc_ncid , loc_varid , tm_seaice_frac , start = ( / 1 , 1 / ), count = ( / n_euphotic_boxes , 12 / )) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) // '-> Fice' ! T status = nf90_inq_varid ( loc_ncid , 'Tbc' , loc_varid ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) // '-> T' status = nf90_get_var ( loc_ncid , loc_varid , tm_T , start = ( / 1 , 1 / ), count = ( / n_euphotic_boxes , 12 / )) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) // '-> T' ! S status = nf90_inq_varid ( loc_ncid , 'Sbc' , loc_varid ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) // '-> S' status = nf90_get_var ( loc_ncid , loc_varid , tm_S , start = ( / 1 , 1 / ), count = ( / n_euphotic_boxes , 12 / )) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) // '-> S' ! silica status = nf90_inq_varid ( loc_ncid , 'silica' , loc_varid ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) // '-> Si' status = nf90_get_var ( loc_ncid , loc_varid , tm_silica , start = ( / 1 , 1 / ), count = ( / n_euphotic_boxes , 12 / )) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) // '-> Si' ! close netcdf file status = nf90_close ( loc_ncid ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) ! convert to fraction of grid-box not covered, so as to calculate once only tm_seaice_frac = 1.0 - tm_seaice_frac end subroutine ! ---------------------------------------------------------------------------------------! ! ---------------------------------------------------------------------------------------! subroutine load_PO4_restore () ! ---------------------------------------------------------------------------------------! !! Loads [PO4] observations from netCDF file for nutrient restoring subroutine ! ---------------------------------------------------------------------------------------! ! local variables integer :: n , status , loc_varid , loc_ncid print * , 'loading in PO4restore data from:' , '../data/' // trim ( tm_PO4restore_filename ) ! open netcdf file status = nf90_open ( '../data/' // trim ( tm_PO4restore_filename ), nf90_nowrite , loc_ncid ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )), tm_PO4restore_filename ! matrix values status = nf90_inq_varid ( loc_ncid , 'PO4_Obs' , loc_varid ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )), 'PO4_Obs' status = nf90_get_var ( loc_ncid , loc_varid , bg_PO4_obs , start = ( / 1 , 1 / ), count = ( / n_euphotic_boxes , 12 / )) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )), 'PO4_Obs' !print*,bg_PO4_obs(1:10,1) ! close netcdf file status = nf90_close ( loc_ncid ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) end subroutine ! ---------------------------------------------------------------------------------------! ! ---------------------------------------------------------------------------------------! subroutine load_Martin_b_spatial () ! ---------------------------------------------------------------------------------------! !! Loads spatially explicit Martin curve \"b\" data from netCDF ! ---------------------------------------------------------------------------------------! ! local variables integer :: n , status , loc_varid , loc_ncid print * , 'loading in spatially varying b data from:' , '../data/' // trim ( bg_martin_b_input_filename ) ! open netcdf file status = nf90_open ( '../data/' // '/' // trim ( bg_martin_b_input_filename ), nf90_nowrite , loc_ncid ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )), bg_martin_b_input_filename ! matrix values status = nf90_inq_varid ( loc_ncid , 'Martin_b' , loc_varid ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )), 'Spatial_Martin_b' status = nf90_get_var ( loc_ncid , loc_varid , bg_martin_b ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )), 'Spatial_Martin_b' !print*,bg_PO4_uptake(1:10,1) ! close netcdf file status = nf90_close ( loc_ncid ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) end subroutine load_Martin_b_spatial ! ---------------------------------------------------------------------------------------! ! ---------------------------------------------------------------------------------------! subroutine load_data_saving () ! ---------------------------------------------------------------------------------------! !! Loads data specifying timeseries and timeslice save points ! ---------------------------------------------------------------------------------------! ! local variables integer :: var_count , n integer :: iostat logical :: exist_file real :: tmp ! ******************** timeseries ******************** ! open, read file for dimension, and allocate INQUIRE ( FILE = '../data/' // trim ( gen_save_timeseries_file ), EXIST = exist_file ) if ( exist_file . eqv .. false .) print * , 'Timeseries input file does not exist' open ( UNIT = 10 , FILE = '../data/' // trim ( gen_save_timeseries_file )) var_count = 0 DO READ ( UNIT = 10 , IOSTAT = iostat , FMT =* ) tmp IF ( iostat < 0 ) THEN exit ELSE var_count = var_count + 1 END IF END DO close ( UNIT = 10 ) allocate ( tm_timeseries ( var_count )) ! read in timeseries save points open ( UNIT = 10 , FILE = '../data/' // trim ( gen_save_timeseries_file )) read ( unit = 10 , iostat = iostat , fmt = '(F10.1)' ) tm_timeseries close ( unit = 10 ) ! ******************** timeslice ******************** ! open, read file for dimension, and allocate INQUIRE ( FILE = '../data/' // trim ( gen_save_timeslice_file ), EXIST = exist_file ) if ( exist_file . eqv .. false .) print * , 'Timeseries input file does not exist' open ( UNIT = 10 , FILE = '../data/' // trim ( gen_save_timeslice_file )) var_count = 0 DO READ ( UNIT = 10 , IOSTAT = iostat , FMT =* ) tmp IF ( iostat < 0 ) THEN exit ELSE var_count = var_count + 1 END IF END DO close ( UNIT = 10 ) allocate ( tm_timeslice ( var_count )) ! read in timeslice save points open ( UNIT = 10 , FILE = '../data/' // trim ( gen_save_timeslice_file )) read ( unit = 10 , iostat = iostat , fmt = '(F10.1)' ) tm_timeslice close ( unit = 10 ) end subroutine load_data_saving ! ---------------------------------------------------------------------------------------! ! ---------------------------------------------------------------------------------------! subroutine initialise_output () ! ---------------------------------------------------------------------------------------! !! Initialises timeslice and timeseries output files !! !! - creates output and restart directories if needed ! ---------------------------------------------------------------------------------------! logical :: exist_dir ! make output directory (if doesn't already exist) INQUIRE ( FILE = '../output/' // trim ( gen_config_filename ), EXIST = exist_dir ) if ( exist_dir . eqv .. false .) then call system ( 'mkdir ../output/' // trim ( gen_config_filename )) end if ! make restart directory (if doesn't already exist) INQUIRE ( FILE = '../output/' // trim ( gen_config_filename ) // '/restart' , EXIST = exist_dir ) if ( exist_dir . eqv .. false .) then call system ( 'mkdir ../output/' // trim ( gen_config_filename ) // '/restart' ) end if ! initialise timeseries and timeslice output files call initialise_timeseries_output () call initialise_timeslice_output () ! write out copy of namelist file open ( unit = 20 , file = '../output/' // trim ( gen_config_filename ) // '/parameter_namelist.txt' , status = 'replace' ) write ( UNIT = 20 , NML = fml_namelist ) close ( unit = 20 ) end subroutine initialise_output ! ---------------------------------------------------------------------------------------! ! ---------------------------------------------------------------------------------------! subroutine initialise_timeseries_output () ! ---------------------------------------------------------------------------------------! !! Initialise timeseries output files ! ---------------------------------------------------------------------------------------! ! atm CO2 open ( unit = 10 , file = '../output/' // trim ( gen_config_filename ) // '/timeseries_atm_CO2.dat' , status = 'replace' ) write ( unit = 10 , fmt = '(A44)' ) '% / year / atmospheric CO2 (mol) / atmospheric CO2 (ppmv)' close ( unit = 10 ) ! PO4 open ( unit = 10 , file = '../output/' // trim ( gen_config_filename ) // '/timeseries_ocn_PO4.dat' , status = 'replace' ) write ( unit = 10 , fmt = '(A100)' ) '% / year / PO4 inventory (mol) / [PO4] global (mmol m-3) / [PO4] surface (mmol m-3)' close ( unit = 10 ) ! DOP open ( unit = 10 , file = '../output/' // trim ( gen_config_filename ) // '/timeseries_ocn_DOP.dat' , status = 'replace' ) write ( unit = 10 , fmt = '(A100)' ) '% / year / DOP inventory (mol) / [DOP] global (mmol m-3)' close ( unit = 10 ) ! DIC open ( unit = 10 , file = '../output/' // trim ( gen_config_filename ) // '/timeseries_ocn_DIC.dat' , status = 'replace' ) write ( unit = 10 , fmt = '(A100)' ) '% / year / DIC inventory (mol) / [DIC] global (mmol m-3) / [DIC] surface (mmol m-3)' close ( unit = 10 ) ! ALK open ( unit = 10 , file = '../output/' // trim ( gen_config_filename ) // '/timeseries_ocn_ALK.dat' , status = 'replace' ) write ( unit = 10 , fmt = '(A100)' ) '% / year / ALK inventory (mol) / [ALK] global (mmol m-3)' close ( unit = 10 ) ! gas exchange open ( unit = 10 , file = '../output/' // trim ( gen_config_filename ) // '/timeseries_airsea_CO2.dat' , status = 'replace' ) write ( unit = 10 , fmt = '(A100)' ) '% / year / global mean flux (mol yr-1) / global mean flux (mol m-2 yr-1)' close ( unit = 10 ) ! POM EXPORT open ( unit = 10 , file = '../output/' // trim ( gen_config_filename ) // '/timeseries_POM_export.dat' , status = 'replace' ) write ( unit = 10 , fmt = '(A100)' ) '% / year / global mean flux (mol yr-1) / global mean flux (mol m-2 yr-1)' close ( unit = 10 ) ! CaCO3 EXPORT open ( unit = 10 , file = '../output/' // trim ( gen_config_filename ) // '/timeseries_CaCO3_export.dat' , status = 'replace' ) write ( unit = 10 , fmt = '(A100)' ) '% / year / global mean flux (mol yr-1) / global mean flux (mol m-2 yr-1)' close ( unit = 10 ) end subroutine initialise_timeseries_output ! ---------------------------------------------------------------------------------------! ! ---------------------------------------------------------------------------------------! subroutine write_timeseries_output () ! ---------------------------------------------------------------------------------------! !! Writes timeseries output to file ! ---------------------------------------------------------------------------------------! real :: rvol_tot , rvol_sur_tot , rvol_deep_tot rvol_tot = 1.0 / sum ( tm_vol ) rvol_sur_tot = 1.0 / sum ( tm_vol ( 1 : n_surface_boxes )) rvol_deep_tot = 1.0 / sum ( tm_vol ( 41153 : 52749 )) ! CO2 open ( unit = 10 , file = '../output/' // trim ( gen_config_filename ) // '/timeseries_atm_CO2.dat' , position = 'append' ) write ( unit = 10 , fmt = '(f12.1,e20.12,f12.6)' ) & t_int , & ATM_int ( iaCO2 ) * ATM_vol , & ATM_int ( iaCO2 ) * 1.0e6 close ( unit = 10 ) !PO4 open ( unit = 10 , file = '../output/' // trim ( gen_config_filename ) // '/timeseries_ocn_PO4.dat' , position = 'append' ) write ( unit = 10 , fmt = '(f12.1,e20.12,f12.6,f12.6,f12.6)' ) & t_int , & sum ( tracers_int (:, ioPO4 ) * tm_vol ) , & sum ( tracers_int (:, ioPO4 ) * tm_vol ) * rvol_tot * 1.0e3 , & sum ( tracers_int ( 1 : n_surface_boxes , ioPO4 ) * tm_vol ( 1 : n_surface_boxes )) * rvol_sur_tot * 1.0e3 , & sum ( tracers_int ( 41153 : 52749 , ioPO4 ) * tm_vol ( 41153 : 52749 )) * rvol_deep_tot * 1.0e3 close ( unit = 10 ) !DOP open ( unit = 10 , file = '../output/' // trim ( gen_config_filename ) // '/timeseries_ocn_DOP.dat' , position = 'append' ) write ( unit = 10 , fmt = '(f12.1,e20.12,f12.6)' ) & t_int , & sum ( tracers_int (:, ioDOP ) * tm_vol ) , & sum ( tracers_int (:, ioDOP ) * tm_vol ) * rvol_tot * 1.0e3 close ( unit = 10 ) !DIC open ( unit = 10 , file = '../output/' // trim ( gen_config_filename ) // '/timeseries_ocn_DIC.dat' , position = 'append' ) write ( unit = 10 , fmt = '(f12.1,e20.12,f12.6,f12.6,f12.6)' ) & t_int , & sum ( tracers_int (:, ioDIC ) * tm_vol ) , & sum ( tracers_int (:, ioDIC ) * tm_vol ) * rvol_tot * 1.0e3 , & sum ( tracers_int ( 1 : n_surface_boxes , ioDIC ) * tm_vol ( 1 : n_surface_boxes )) * rvol_sur_tot * 1.0e3 , & sum ( tracers_int ( 41153 : 52749 , ioDIC ) * tm_vol ( 41153 : 52749 )) * rvol_deep_tot * 1.0e3 close ( unit = 10 ) !ALK open ( unit = 10 , file = '../output/' // trim ( gen_config_filename ) // '/timeseries_ocn_ALK.dat' , position = 'append' ) write ( unit = 10 , fmt = '(f12.1,e20.12,f12.6)' ) & t_int , & sum ( tracers_int (:, ioALK ) * tm_vol ) , & sum ( tracers_int (:, ioALK ) * tm_vol ) * rvol_tot * 1.0e3 close ( unit = 10 ) !gas exchange open ( unit = 10 , file = '../output/' // trim ( gen_config_filename ) // '/timeseries_airsea_CO2.dat' , position = 'append' ) write ( unit = 10 , fmt = '(f12.1,e20.12,e20.12)' ) & t_int , & sum ( diag_int (:, 2 )), & sum ( diag_int (:, 2 )) / sum ( tm_area ( 1 : n_surface_boxes )) ! check this close ( unit = 10 ) !POM export open ( unit = 10 , file = '../output/' // trim ( gen_config_filename ) // '/timeseries_POM_export.dat' , position = 'append' ) write ( unit = 10 , fmt = '(f12.1,e20.12)' ) & t_int , & sum ( diag_int (:, 3 )) close ( unit = 10 ) !POM export open ( unit = 10 , file = '../output/' // trim ( gen_config_filename ) // '/timeseries_CaCO3_export.dat' , position = 'append' ) write ( unit = 10 , fmt = '(f12.1,e20.12)' ) & t_int , & sum ( diag_int (:, 6 )) close ( unit = 10 ) end subroutine write_timeseries_output ! ---------------------------------------------------------------------------------------! ! ---------------------------------------------------------------------------------------! subroutine initialise_timeslice_output () ! ---------------------------------------------------------------------------------------! !! Initialises netCDF output ! ---------------------------------------------------------------------------------------! integer :: ncid , status , m_dimid , n_dimid , PO4id , DOPid , EXPORTid , n_season , DICid , ALKid , airseaCO2id , popreminid , po4uptakeid integer :: lon_dimid , lat_dimid , depth_dimid !integer::dimids(2) integer :: dimids ( 4 ) !create file status = nf90_create ( '../output/' // trim ( gen_config_filename ) // '/fields_netcdf.nc' , nf90_clobber , ncid ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) !define dimensions !status=nf90_def_dim(ncid,'tm_nbox',tm_nbox,m_dimid) !if(status /= nf90_NoErr) print*,trim(nf90_strerror(status)) status = nf90_def_dim ( ncid , 'lon' , NX , lon_dimid ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) status = nf90_def_dim ( ncid , 'lat' , NY , lat_dimid ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) status = nf90_def_dim ( ncid , 'depth' , NZ , depth_dimid ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) status = nf90_def_dim ( ncid , 'time' , nf90_unlimited , n_dimid ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) dimids = ( / lon_dimid , lat_dimid , depth_dimid , n_dimid / ) !dimids=(/m_dimid,n_dimid/) !define variable status = nf90_def_var ( ncid , 'PO4' , nf90_float , dimids , PO4id ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) status = nf90_def_var ( ncid , 'DOP' , nf90_float , dimids , DOPid ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) status = nf90_def_var ( ncid , 'DIC' , nf90_float , dimids , DICid ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) status = nf90_def_var ( ncid , 'ALK' , nf90_float , dimids , ALKid ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) status = nf90_def_var ( ncid , 'airsea_CO2_flux' , nf90_float , dimids , airseaCO2id ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) status = nf90_def_var ( ncid , 'PO4_uptake' , nf90_float , dimids , po4uptakeid ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) status = nf90_def_var ( ncid , 'POP_remin' , nf90_float , dimids , popreminid ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) status = nf90_def_var ( ncid , 'CaCO3_export' , nf90_float , dimids , popreminid ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) status = nf90_def_var ( ncid , 'CaCO3_remin' , nf90_float , dimids , popreminid ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) !status=nf90_def_var(ncid,'EXPORT',nf90_float,dimids,EXPORTid) !if(status /= nf90_NoErr) print*,trim(nf90_strerror(status)) !end definition status = nf90_enddef ( ncid ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) ! close file status = nf90_close ( ncid ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) end subroutine initialise_timeslice_output ! ---------------------------------------------------------------------------------------! ! ---------------------------------------------------------------------------------------! subroutine write_output_netcdf () ! ---------------------------------------------------------------------------------------! !! writes netCDF output !! !! - currently just for the last timestep!! ! ---------------------------------------------------------------------------------------! integer :: ncid , status , var_id real , dimension ( NX , NY , NZ ) :: field !open file status = nf90_open ( '../output/' // trim ( gen_config_filename ) // '/fields_netcdf.nc' , nf90_write , ncid ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) ! inquire ids and write data ! PO4 status = nf90_inq_varid ( ncid , 'PO4' , var_id ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) field = v2f ( tracers_int (:, ioPO4 )) status = nf90_put_var ( ncid , var_id , field , start = ( / 1 , 1 , 1 , timeslice_count / ), count = ( / NX , NY , NZ , 1 / )) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) ! ! DOP status = nf90_inq_varid ( ncid , 'DOP' , var_id ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) field = v2f ( tracers_int (:, ioDOP )) status = nf90_put_var ( ncid , var_id , field , start = ( / 1 , 1 , 1 , timeslice_count / ), count = ( / NX , NY , NZ , 1 / )) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) ! ! ! DIC status = nf90_inq_varid ( ncid , 'DIC' , var_id ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) field = v2f ( tracers_int (:, ioDIC )) status = nf90_put_var ( ncid , var_id , field , start = ( / 1 , 1 , 1 , timeslice_count / ), count = ( / NX , NY , NZ , 1 / )) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) ! ! ! ALK status = nf90_inq_varid ( ncid , 'ALK' , var_id ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) field = v2f ( tracers_int (:, ioALK )) status = nf90_put_var ( ncid , var_id , field , start = ( / 1 , 1 , 1 , timeslice_count / ), count = ( / NX , NY , NZ , 1 / )) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) ! ! ! air-sea CO2 flux status = nf90_inq_varid ( ncid , 'airsea_CO2_flux' , var_id ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) field = v2f ( diag_int (:, 1 )) status = nf90_put_var ( ncid , var_id , field , start = ( / 1 , 1 , 1 , timeslice_count / ), count = ( / NX , NY , NZ , 1 / )) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) ! ! PO4 uptake status = nf90_inq_varid ( ncid , 'PO4_uptake' , var_id ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) field = v2f ( diag_int (:, 3 )) status = nf90_put_var ( ncid , var_id , field , start = ( / 1 , 1 , 1 , timeslice_count / ), count = ( / NX , NY , NZ , 1 / )) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) ! ! POP remin status = nf90_inq_varid ( ncid , 'POP_remin' , var_id ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) field = v2f ( diag_int (:, 4 )) status = nf90_put_var ( ncid , var_id , field , start = ( / 1 , 1 , 1 , timeslice_count / ), count = ( / NX , NY , NZ , 1 / )) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) ! ! POP remin status = nf90_inq_varid ( ncid , 'CaCO3_export' , var_id ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) field = v2f ( diag_int (:, 6 )) status = nf90_put_var ( ncid , var_id , field , start = ( / 1 , 1 , 1 , timeslice_count / ), count = ( / NX , NY , NZ , 1 / )) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) ! ! POP remin status = nf90_inq_varid ( ncid , 'CaCO3_remin' , var_id ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) field = v2f ( diag_int (:, 5 )) status = nf90_put_var ( ncid , var_id , field , start = ( / 1 , 1 , 1 , timeslice_count / ), count = ( / NX , NY , NZ , 1 / )) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) ! close file status = nf90_close ( ncid ) if ( status /= nf90_NoErr ) print * , trim ( nf90_strerror ( status )) !print*,'Output written to: ','../output/'//trim(gen_config_filename)//'.nc' end subroutine write_output_netcdf ! ---------------------------------------------------------------------------------------! ! ---------------------------------------------------------------------------------------! subroutine write_restart () ! ---------------------------------------------------------------------------------------! !! Writes state variables to binary for restart ! ---------------------------------------------------------------------------------------! integer :: ios open ( unit = 10 , form = 'unformatted' , status = 'replace' , action = 'write' , iostat = ios , & file = '../output/' // trim ( gen_config_filename ) // '/restart/restart.bin' ) write ( 10 ) tracers_1 , ATM close ( 10 , iostat = ios ) print * , 'Restart saved to' // '../output/' // trim ( gen_config_filename ) // '/restart/restart.bin' end subroutine write_restart ! ---------------------------------------------------------------------------------------! ! ---------------------------------------------------------------------------------------! subroutine load_restart () ! ---------------------------------------------------------------------------------------! !! Loads state variables from binary from restart experiment ! ---------------------------------------------------------------------------------------! integer :: ios open ( unit = 10 , status = 'old' , form = 'unformatted' , action = 'read' , IOSTAT = ios , & file = '../output/' // trim ( gen_restart_filename ) // '/restart/restart.bin' ) read ( 10 , iostat = ios ) tracers_1 , ATM close ( 10 , iostat = ios ) end subroutine load_restart ! ---------------------------------------------------------------------------------------! ! ---------------------------------------------------------------------------------------! subroutine write_PO4_uptake () ! ---------------------------------------------------------------------------------------! !! Write PO4 uptake to binary for fixed export subroutine ! ---------------------------------------------------------------------------------------! integer :: ios if ( tm_save_PO4_uptake ) then open ( unit = 10 , form = 'unformatted' , status = 'replace' , action = 'write' , iostat = ios , & file = '../output/' // trim ( gen_config_filename ) // '/PO4_uptake.bin' ) write ( 10 , iostat = ios ) export_save_int close ( 10 , iostat = ios ) print * , 'Fixed PO4 uptake saved to:' , '../output/' // trim ( gen_config_filename ) // '/PO4_uptake.bin' endif end subroutine write_PO4_uptake ! ---------------------------------------------------------------------------------------! ! ---------------------------------------------------------------------------------------! subroutine load_PO4_uptake () ! ---------------------------------------------------------------------------------------! !! Load PO4 uptake binary for fixed uptake subroutine ! ---------------------------------------------------------------------------------------! integer :: ios print * , 'loading in fixed PO4 uptake data from:' , '../data/' // trim ( tm_PO4uptake_filename ) open ( unit = 10 , status = 'old' , form = 'unformatted' , action = 'read' , IOSTAT = ios , & file = '../data/' // trim ( tm_PO4uptake_filename )) read ( 10 , iostat = ios ) bg_PO4_uptake close ( 10 , iostat = ios ) end subroutine load_PO4_uptake ! ---------------------------------------------------------------------------------------! ! ---------------------------------------------------------------------------------------! function v2f ( vector ) ! ---------------------------------------------------------------------------------------! !! reorder vector into a 3D field ! ---------------------------------------------------------------------------------------! real , dimension ( NX , NY , NZ ) :: v2f real , dimension ( tm_nbox ) :: vector integer :: n v2f (:,:,:) = 0.0 do n = 1 , tm_nbox v2f ( tm_i ( n ), tm_j ( n ), tm_k ( n )) = vector ( n ); enddo end function v2f ! ---------------------------------------------------------------------------------------! ! END OF MODULE ! ---------------------------------------------------------------------------------------! end module io_module","tags":"","loc":"sourcefile/io_module.f90.html"},{"title":"bg_module.f90 – Fortran Matrix Lab","text":"This file depends on sourcefile~~bg_module.f90~~EfferentGraph sourcefile~bg_module.f90 bg_module.f90 sourcefile~tm_module.f90 tm_module.f90 sourcefile~bg_module.f90->sourcefile~tm_module.f90 sourcefile~fml_lib.f90 fml_lib.f90 sourcefile~bg_module.f90->sourcefile~fml_lib.f90 sourcefile~tm_module.f90->sourcefile~fml_lib.f90 sourcefile~io_module.f90 io_module.f90 sourcefile~tm_module.f90->sourcefile~io_module.f90 sourcefile~io_module.f90->sourcefile~fml_lib.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~bg_module.f90~~AfferentGraph sourcefile~bg_module.f90 bg_module.f90 sourcefile~fml.f90 fml.f90 sourcefile~fml.f90->sourcefile~bg_module.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules bg_module Source Code bg_module.f90 Source Code module bg_module ! ---------------------------------------------------------------------------------------! !! Subroutines related to biogeochemistry ! ---------------------------------------------------------------------------------------! use fml_lib use tm_module implicit none contains ! ---------------------------------------------------------------------------------------! ! ---------------------------------------------------------------------------------------! subroutine PO4_uptake () ! ---------------------------------------------------------------------------------------! !! Calculates PO4 uptake !! !! - calculates biological uptake of PO4 !! - updates other tracers via Redfield ratios !! - calculates CaCO3 export via a rain-ratio ! ---------------------------------------------------------------------------------------! integer :: n real :: uptake real , dimension ( n_euphotic_boxes ) :: tmp_PO4 do n = 1 , n_euphotic_boxes uptake = 0.0 select case ( trim ( bg_uptake_function )) case ( 'restore' ) tmp_PO4 = ( tm_seasonal_scale ( dt_count ) * bg_PO4_obs (:, tm_seasonal_n1 ( dt_count )))& + & (( tm_seasonal_rscale ( dt_count )) * bg_PO4_obs (:, tm_seasonal_n2 ( dt_count ))) if ( tracers_1 ( n , ioPO4 ) > tmp_PO4 ( n )) uptake = seaice_dt ( n ) * bg_uptake_tau * ( tracers_1 ( n , ioPO4 ) - tmp_PO4 ( n )) ! PO4 uptake case ( 'fixed' ) uptake = 0.0 ! set to zero initially, update if if ( tracers_1 ( n , ioPO4 ) - ( bg_PO4_uptake ( n , dt_count ) * bg_dt ) > 0.0 ) uptake = bg_PO4_uptake ( n , dt_count ) ! PO4 uptake case ( 'abiotic' ) uptake = 0.0 end select J ( n , ioPO4 ) = J ( n , ioPO4 ) - uptake ! PO4 J ( n , ioDOP ) = J ( n , ioDOP ) + bg_DOC_frac * uptake ! DOP particles ( n , isPOP ) = particles ( n , isPOP ) + bg_DOC_rfrac * uptake ! POP if ( bg_C_select ) then ! OM J ( n , ioDIC ) = J ( n , ioDIC ) - ( uptake * bg_C_to_P ) J ( n , ioALK ) = J ( n , ioALK ) + ( uptake * bg_N_to_P ) ! CaCO3 precipitation particles ( n , isCaCO3 ) = particles ( n , isCaCO3 ) + ( bg_DOC_rfrac * uptake * bg_C_to_P * bg_rain_ratio ) J ( n , ioDIC ) = J ( n , ioDIC ) - ( bg_DOC_rfrac * uptake * bg_C_to_P * bg_rain_ratio ) J ( n , ioALK ) = J ( n , ioALK ) - ( bg_DOC_rfrac * uptake * bg_C_to_P * bg_rain_ratio * 2.0 ) end if diag ( n , 3 ) = uptake * tm_vol ( n ) ! mol diag ( n , 6 ) = ( bg_DOC_rfrac * uptake * bg_C_to_P * bg_rain_ratio ) * tm_vol ( n ) if ( tm_save_PO4_uptake ) export_save ( n ) = uptake ! save export end do end subroutine PO4_uptake ! ---------------------------------------------------------------------------------------! ! ---------------------------------------------------------------------------------------! subroutine DOP_remin () ! ---------------------------------------------------------------------------------------! !! Dissolved organic phosphorus remineralisation ! ---------------------------------------------------------------------------------------! integer :: n real :: remin do n = 1 , tm_nbox if ( tracers_1 ( n , ioDOP ). gt . 1 e - 8 ) then ! Kriest et al., (2010) . Also smaller concentrations slow down the matrix calculation significantly. remin = tracers_1 ( n , ioDOP ) * bg_DOC_k if ( remin * bg_dt . lt . tracers_1 ( n , ioDOP )) then ! catch remineralisation making DOP go negative J ( n , ioPO4 ) = J ( n , ioPO4 ) + remin ! DOP remin -> PO4 J ( n , ioDOP ) = J ( n , ioDOP ) - remin ! DOP remin <- DOP if ( bg_C_select ) then J ( n , ioDIC ) = J ( n , ioDIC ) + ( remin * bg_C_to_P ) J ( n , ioALK ) = J ( n , ioALK ) - ( remin * bg_N_to_P ) end if end if end if end do end subroutine DOP_remin ! ---------------------------------------------------------------------------------------! ! ---------------------------------------------------------------------------------------! ! subroutine POP_remin() ! ! real,dimension(tm_nbox)::remin ! ! remin=amul(Aremin,(particles(:,isPOP))) ! POP remineralisation ! ! J(:,ioPO4)=J(:,ioPO4)+remin ! ! if(bg_C_select)then ! \tJ(:,ioDIC)=J(:,ioDIC)+(remin*bg_C_to_P) ! \tJ(:,ioALK)=J(:,ioALK)-(remin*bg_N_to_P) ! endif ! ! diag(:,4)=remin ! ! end subroutine POP_remin ! ---------------------------------------------------------------------------------------! ! ---------------------------------------------------------------------------------------! subroutine update_bgc () ! ---------------------------------------------------------------------------------------! !! add biogeochemical sources/sinks to state arrays ! ---------------------------------------------------------------------------------------! integer :: n , n_tracer do n_tracer = 1 , gen_n_tracers do n = 1 , tm_nbox tracers ( n , n_tracer ) = tracers ( n , n_tracer ) + J ( n , n_tracer ) * bg_dt enddo enddo ATM ( iaCO2 ) = ATM ( iaCO2 ) + sum ( Jatm (:, iaCO2 )) * bg_dt / ATM_mol end subroutine update_bgc ! ---------------------------------------------------------------------------------------! ! ---------------------------------------------------------------------------------------! subroutine calc_C_consts () ! ---------------------------------------------------------------------------------------! !! Calculate carbonate system constants !! - uses DOE (1994) ! ---------------------------------------------------------------------------------------! real :: T , S , I integer :: n ! to do: add C_consts to fml_lib.f90 do n = 1 , n_surface_boxes T = T_dt ( n ) + 27 3.15 S = S_dt ( n ) ! K1 (Roy et al., 1993) C_consts ( n , iK1 ) = exp ( 2.83655 - 230 7.1266 / T - 1.5529413 * log ( T ) & - ( 0.207608410 + 4.0484 / T ) * sqrt ( S ) & + 0.0846834 * S - 0.00654208 * S ** ( 3.0 / 2.0 ) + log ( 1.0 - 0.001005 * S )) ! K2 (Roy et al., 1993) C_consts ( n , iK2 ) = exp ( & - 9.226508 - 335 1.6106 / T - 0.2005743 * log ( T ) & - ( 0.106901773 + 2 3.9722 / T ) * sqrt ( S ) & + 0.1130822 * S - 0.00846934 * S ** ( 3.0 / 2.0 ) + log ( 1.0 - 0.001005 * S )) ! K0 (Weiss 1974) C_consts ( n , iK0 ) = exp ( & 934 5.17 / T - 6 0.2409 + 2 3.3585 * log ( T / 10 0.0 ) & + S * ( 0.023517 - 0.00023656 * T + 0.0047036 * ( T / 10 0.0 ) ** 2 )) ! KB (Dickson 1990b( C_consts ( n , iKb ) = exp ( & ( - 896 6.90 - 289 0.53 * S ** 0.5 - 7 7.942 * S + 1.728 * S ** ( 3.0 / 2.0 ) - 0.0996 * S ** 2.0 ) / T & + 14 8.0248 + 13 7.1942 * S ** 0.5 + 1.62142 * S & - ( 2 4.4344 + 2 5.085 * S ** 0.5 + 0.2474 * S ) * log ( T ) & + 0.053105 * S ** 0.5 * T ) ! Kw (Millero 1995) C_consts ( n , iKw ) = exp ( & 14 8.96502 - 1384 7.26 / T - 2 3.6521 * log ( T ) & + ( 11 8.67 / T - 5.977 + 1.0495 * log ( T )) * S ** 0.5 - 0.01615 * S ) !KSi (Millero 1995) I = ( 1 9.924 * S ) / ( 100 0.0 - 1.005 * S ) !I=0.02*S C_consts ( n , iKSi ) = exp ( & - 890 4.2 / T + 11 7.385 - 1 9.334 * log ( T ) & + (( - 45 8.79 / T + 3.5913 ) * ( I ** ( - 0.5 )) & + ( 18 8.74 / T - 1.5998 )) * I & + ( - 1 2.1652 / T + 0.07871 ) * ( I ** 2 ) & + log ( 1.0 - 0.001005 * S )) ! KP1 (Millero 1995) C_consts ( n , iKp1 ) = exp ( & - 457 6.752 / T + 11 5.525 - 1 8.453 * log ( T ) & + ( - 10 6.736 / T + 0.69171 ) * S ** 0.5 & + ( - 0.65643 / T - 0.01844 ) * S ) ! KP2 (Millero 1995) C_consts ( n , iKp2 ) = exp ( & - 881 4.715 / T + 17 2.0883 - 2 7.927 * log ( T ) & + ( - 16 0.34 / T + 1.3566 ) * S ** 0.5 & + ( 0.37335 / T - 0.05778 ) * S ) ! KP3 (millero 1995) C_consts ( n , iKp3 ) = exp ( & - 307 0.75 / T - 1 8.141 & + ( 1 7.27039 / T + 2.81197 ) * S ** 0.5 & + ( - 4 4.99486 / T - 0.09984 ) * S ) enddo ! compare with DOE (1994) !print*,'T',T !print*,'S',S !print*,'K1',log(C_consts(1,iK1)),(C_consts(1,iK1)) !print*,'K2',log(C_consts(1,iK2)),(C_consts(1,iK2)) !print*,'K0',log(C_consts(1,iK0)),(C_consts(1,iK0)) !print*,'Kw',log(C_consts(1,iKw)),(C_consts(1,iKw)) !print*,'KB',log(C_consts(1,iKB)),(C_consts(1,iKB)) !print*,'KSi',log(C_consts(1,iKSi)),(C_consts(1,iKSi)) !print*,'Kp1',log(C_consts(1,iKp1)),(C_consts(1,iKp1)) !print*,'Kp2',log(C_consts(1,iKp2)),(C_consts(1,iKp2)) !print*,'Kp3',log(C_consts(1,iKp3)),(C_consts(1,iKp3)) end subroutine calc_C_consts ! ---------------------------------------------------------------------------------------! ! ---------------------------------------------------------------------------------------! subroutine calc_pCO2 () ! ---------------------------------------------------------------------------------------! !! Solve carbonate system for pC02 !! - M. Follows, T. Ito, S. Dutkiewicz (2006) in Ocean Modelling ! ---------------------------------------------------------------------------------------! ! local variables real :: pt , sit , ta , pco2 , dic , H , bt , k1 , k2 , k1p , k2p , k3p , kb , kw , ksi , k0 ! ff in original but not used, added k0 real :: gamm , co2s , hg , cag , bohg , h3po4g , h2po4g , hpo4g , po4g , siooh3g , denom , dummy , fg integer :: n , n_loop real :: h_guess_1 , h_guess_2 ! dic = dissolved inorganic carbon; pt = dissolved inorganic phosphorus ! sit = dissolved inorganic silica, bt = dissolved inorganic boron ! ta = total alkalinity; ca = carbonate alkalinity; H = [H+] ! pCO2 = partial pressure CO2; ff = fugacity of CO2 ! k1, k2 = carbonate equilibrium coeffs; kw = dissociation of water ! klp, k2p, k3p = phosphate equilibrium coefficients ! ksi, kb = silicate and borate equilibrium coefficients ! Equilibrium relationships from DOE handbook (DOE, 1994): ! coefficients evaluated elsewhere and passed in. do n = 1 , n_surface_boxes ! initialise variables dic = tracers_1 ( n , ioDIC ) * r_rho ! mol m-3 -> mol kg-1 ta = tracers_1 ( n , ioALK ) * r_rho ! mol m-3 -> mol kg-1 pt = tracers_1 ( n , ioPO4 ) * r_rho ! mol m-3 -> mol kg-1 !sit=silica_dt(n) sit = 7.5 / 1.0e6 ! global mean surface (Orr et al., 2017) umol kg-1 -> mol kg-1 bt = 0.0004106 * ( S_dt ( n ) / 3 5.0 ) ! total boron conc. from ZW2001 (mol kg-1) k1 = C_consts ( n , iK1 ) k2 = C_consts ( n , iK2 ) kw = C_consts ( n , iKw ) k1p = C_consts ( n , iKp1 ) k2p = C_consts ( n , iKp2 ) k3p = C_consts ( n , iKp3 ) ksi = C_consts ( n , iKSi ) kb = C_consts ( n , iKb ) k0 = C_consts ( n , iK0 ) ! First guess of [H+]: from last timestep *OR* fixed for cold start if ( C ( n , ioH ). eq . - 1.0 ) then hg = 1 0 e - 8 ! cold start h_guess_1 = 1.0 h_guess_2 = hg else hg = C ( n , ioH ) ! previous timestep h_guess_1 = 1.0 h_guess_2 = hg endif n_loop = 0 do while ( abs ( h_guess_1 - h_guess_2 ) > carbchem_tol ) ! estimate contributions to total alk from borate, silicate, phosphate bohg = bt * kb / ( hg + kb ) siooh3g = sit * ksi / ( ksi + hg ) denom = hg * hg * hg + ( k1p * hg * hg ) + ( k1p * k2p * hg ) + ( k1p * k2p * k3p ) h3po4g = ( pt * hg * hg * hg ) / denom h2po4g = ( pt * k1p * hg * hg ) / denom hpo4g = ( pt * k1p * k2p * hg ) / denom po4g = ( pt * k1p * k2p * k3p ) / denom ! estimate carbonate alkalinity fg = - bohg - ( kw / hg ) + hg - hpo4g - 2.0 * po4g + h3po4g - siooh3g cag = ta + fg ! improved estimate of hydrogen ion conc gamm = dic / cag dummy = ( 1.0 - gamm ) * ( 1.0 - gamm ) * k1 * k1 - 4.0 * k1 * k2 * ( 1.0 - 2.0 * gamm ) H = 0.5 * (( gamm - 1.0 ) * k1 + sqrt ( dummy )) hg = H h_guess_1 = h_guess_2 h_guess_2 = hg n_loop = n_loop + 1 if ( n_loop . eq . 10 ) exit ! get-out clause end do ! evaluate [CO2*] co2s = dic / ( 1.0 + ( k1 / H ) + ( k1 * k2 / ( H * H ))) !evaluate surface pCO2 pco2 = dic / k0 * (( 1.0 + k1 / H + ( k1 * k2 ) / ( H * H )) ** ( - 1.0 )) C ( n , ioCO2 ) = co2s * rho ! mol kg-1 -> mol m-3 C ( n , ioH ) = H C ( n , iopCO2 ) = pco2 enddo end subroutine calc_pCO2 ! ---------------------------------------------------------------------------------------! ! ---------------------------------------------------------------------------------------! subroutine calc_gasexchange () ! ---------------------------------------------------------------------------------------! !! Calculate gas exchange between atmosphere and ocean !! - Orr et al., (2017) Geoscientific Model Development ! ---------------------------------------------------------------------------------------! real :: loc_T , loc_T2 , loc_T3 , loc_T4 , loc_Tr100 , loc_T100_2 , loc_TK , loc_S , loc_T100 REAL :: Sc , Bunsen , Sol , gasex real :: kw , CO2star , CO2starair real , dimension ( n_ATM_tracers ) :: atm_dt integer :: n atm_dt = ATM ! copy ATM so can integrate main tracer below do n = 1 , n_surface_boxes loc_T = T_dt ( n ) loc_S = S_dt ( n ) if ( loc_T <- 2.0 ) loc_T =- 2.0 if ( loc_T > 4 0.0 ) loc_T = 4 0.0 loc_T2 = loc_T * loc_T loc_T3 = loc_T2 * loc_T loc_T4 = loc_T3 * loc_T loc_TK = loc_T + 27 3.15 loc_Tr100 = 10 0.0 / loc_TK loc_T100 = loc_TK / 10 0.0 loc_T100_2 = loc_T100 * loc_T100 if ( bg_C_select ) then Sc = Sc_coeffs ( 1 , iaCO2 ) & + Sc_coeffs ( 2 , iaCO2 ) * loc_T & + Sc_coeffs ( 3 , iaCO2 ) * loc_T2 & + Sc_coeffs ( 4 , iaCO2 ) * loc_T3 & + Sc_coeffs ( 5 , iaCO2 ) * loc_T4 Sol = exp ( & Sol_Orr ( 1 , iaCO2 ) & + Sol_Orr ( 2 , iaCO2 ) * loc_Tr100 & + Sol_Orr ( 3 , iaCO2 ) * log ( loc_T100 ) & + Sol_Orr ( 4 , iaCO2 ) * loc_T100_2 & + loc_S * & ( Sol_Orr ( 5 , iaCO2 ) & + Sol_Orr ( 6 , iaCO2 ) * loc_T100 & + Sol_Orr ( 7 , iaCO2 ) * loc_T100_2 )) ! mol L-3 atm-1 Sol = Sol * 100 0.0 ! mol L-1 atm-1 -> mol m-3 atm-1 kw = wind_dt ( n ) * (( Sc / 66 0.0 ) ** ( - 0.5 )) ! in m yr-1 (conversion factors and parameter a computed in wind_dt) CO2starair = Sol * ATM ( iaCO2 ) ! [CO2*]sat (mol m-3) CO2star = C ( n , ioCO2 ) ! [CO2*] (mol m-3) gasex = kw * ( CO2starair - CO2star ) * ( 1.0 / 5 0.0 ) ! air -> sea, mol m-3 yr-1 (n.b. hard coded depth in m!!) J ( n , ioDIC ) = J ( n , ioDIC ) + gasex ! update ocean source/sink Jatm ( n , iaCO2 ) = Jatm ( n , iaCO2 ) - ( gasex * tm_vol ( n )) ! update atmosphere (mol yr-1) diag ( n , 2 ) = gasex * tm_vol ( n ) ! mol yr-1 diag ( n , 1 ) = gasex * 5 0.0 ! mol m-2 yr-1 ! if(n.eq.2000)then ! print*,'n',n ! print*,'co2starair',CO2starair ! print*,'co2star',CO2star ! print*,'wind',wind_dt(n) ! print*,'Sc',Sc,((Sc/660.0)**(-0.5)) ! print*,'T',T_dt(n) ! print*,'S',S_dt(n) ! print*,'dic',tracers_1(n,ioDIC) ! mol m-3 -> mol kg-1 ! print*,'ta',tracers_1(n,ioALK) ! mol m-3 -> mol kg-1 ! print*,'phos',tracers_1(n,ioPO4)! mol m-3 -> mol kg-1 ! print*,'Si',(7.5/1.0e6)*rho ! print*,'CO2atm',ATM(iaCO2) ! print*,'gasex',kw*(CO2starair-0.17285),86.399*((Sc/660.0)**(-0.5))*(CO2starair-0.17285) ! stop ! endif endif enddo end subroutine calc_gasexchange ! ---------------------------------------------------------------------------------------! ! ---------------------------------------------------------------------------------------! subroutine restore_atm_CO2 () ! ---------------------------------------------------------------------------------------! !! Applies a restoring forcing for CO2 ! ---------------------------------------------------------------------------------------! if ( bg_restore_atm_CO2 ) ATM ( iaCO2 ) = bg_restore_atm_CO2_target * 1.0e-6 end subroutine restore_atm_CO2 ! ---------------------------------------------------------------------------------------! ! ---------------------------------------------------------------------------------------! subroutine water_column () ! ---------------------------------------------------------------------------------------! !! Implicit remineralisation of particulate organic carbon and CaCO3 ! ---------------------------------------------------------------------------------------! integer :: n , count , nn integer , dimension ( maxval ( tm_wc )) :: loc_wc_start , loc_wc_end integer , dimension ( tm_nbox ) :: loc_wc real , dimension ( tm_nbox ) :: loc_particles , loc_vol , remin , loc_depth_btm , profile , loc_particles_copy , loc_b real , dimension ( tm_nbox ) :: loc_rvol !real::loc_poc,loc_remin_tot,loc_poc_copy real :: layerratio , frac , pom_above real :: start , finish ! ************* Convert grid arrays to water column order ********************** ! loc_wc = amul ( Aconv , real ( tm_wc )) loc_vol = amul ( Aconv , tm_vol ) loc_depth_btm = amul ( Aconv , tm_depth_btm ) loc_b = amul ( Aconv , bg_martin_b ) loc_rvol = 1.0 / loc_vol ! find water column starting/end points loc_wc_start ( 1 ) = 1 count = 2 do n = 2 , tm_nbox if ( loc_wc ( n ). gt . loc_wc ( n - 1 )) then loc_wc_start ( count ) = n loc_wc_end ( count - 1 ) = n - 1 count = count + 1 endif enddo loc_wc_end ( maxval ( tm_wc )) = tm_nbox ! ************* POM Remin ********************** ! ! pre-calculate curve ! loc_particles=amul(Aconv,particles(:,isPOP)) ! remin=(loc_depth_btm/120.0)**(bg_martin_b) ! loc_particles=loc_particles*loc_vol ! mol m-3 -> mol ! new loc_particles = amul ( Aconv , particles (:, isPOP )) profile = ( loc_depth_btm / 12 0.0 ) ** ( loc_b ) loc_particles_copy = loc_particles remin (:) = 0.0 do n = 1 , maxval ( loc_wc ) if ( loc_wc_end ( n ) - loc_wc_start ( n ) == 0 ) then ! no water column below nn = loc_wc_end ( n ) remin ( nn ) = loc_particles ( nn ) elseif ( loc_wc_end ( n ) - loc_wc_start ( n ) == 1 ) then ! no water column below nn = loc_wc_end ( n ) layerratio = loc_vol ( nn - 1 ) * loc_rvol ( nn ) pom_above = loc_particles ( nn - 1 ) * layerratio remin ( nn ) = loc_particles ( nn ) + pom_above else do nn = loc_wc_start ( n ) + 1 , loc_wc_end ( n ) ! loop over water column layerratio = loc_vol ( nn - 1 ) * loc_rvol ( nn ) pom_above = loc_particles ( nn - 1 ) * layerratio if ( nn <= loc_wc_start ( n ) + 1 ) then ! surface loc_particles ( nn ) = loc_particles ( nn ) + pom_above ! add particles from layer above loc_particles ( nn - 1 ) = 0.0 elseif ( nn > loc_wc_start ( n ) + 1 . and . nn < loc_wc_end ( n )) then ! interior frac = ( profile ( nn ) / profile ( nn - 1 )) loc_particles ( nn ) = pom_above * frac remin ( nn ) = pom_above - loc_particles ( nn ) else loc_particles ( nn ) = 0.0 remin ( nn ) = pom_above - loc_particles ( nn ) endif enddo endif !print*,n,loc_wc_end(n)-loc_wc_start(n),sum(remin(loc_wc_start(n):loc_wc_end(n))* & !loc_vol(loc_wc_start(n):loc_wc_end(n))) & !/sum(loc_vol(loc_wc_start(n):loc_wc_end(n))) - & !sum(loc_particles_copy(loc_wc_start(n):loc_wc_end(n))*loc_vol(loc_wc_start(n):loc_wc_end(n))) & !/sum(loc_vol(loc_wc_start(n):loc_wc_end(n))) enddo !print*,n,sum(remin*loc_vol)/sum(loc_vol)-sum(loc_particles_copy*loc_vol)/sum(loc_vol) remin = amul_transpose ( Aconv , remin ) J (:, ioPO4 ) = J (:, ioPO4 ) + remin ! POP remineralisation diag (:, 4 ) = remin if ( bg_C_select ) then ! OM remineralisation J (:, ioDIC ) = J (:, ioDIC ) + remin * bg_C_to_P J (:, ioALK ) = J (:, ioALK ) - remin * bg_N_to_P endif ! ************* CaCO3 Dissolution ********************** ! loc_particles = amul ( Aconv , particles (:, isCaCO3 )) profile = exp (( 12 0.0 - loc_depth_btm ) / bg_CaCO3_length_scale ) loc_particles_copy = loc_particles remin (:) = 0.0 do n = 1 , maxval ( loc_wc ) if ( loc_wc_end ( n ) - loc_wc_start ( n ) == 0 ) then ! no water column below nn = loc_wc_end ( n ) remin ( nn ) = loc_particles ( nn ) elseif ( loc_wc_end ( n ) - loc_wc_start ( n ) == 1 ) then ! no water column below nn = loc_wc_end ( n ) layerratio = loc_vol ( nn - 1 ) * loc_rvol ( nn ) pom_above = loc_particles ( nn - 1 ) * layerratio remin ( nn ) = loc_particles ( nn ) + pom_above else do nn = loc_wc_start ( n ) + 1 , loc_wc_end ( n ) ! loop over water column layerratio = loc_vol ( nn - 1 ) * loc_rvol ( nn ) pom_above = loc_particles ( nn - 1 ) * layerratio if ( nn <= loc_wc_start ( n ) + 1 ) then ! surface loc_particles ( nn ) = loc_particles ( nn ) + pom_above ! add particles from layer above loc_particles ( nn - 1 ) = 0.0 elseif ( nn > loc_wc_start ( n ) + 1 . and . nn < loc_wc_end ( n )) then ! interior frac = ( profile ( nn ) / profile ( nn - 1 )) loc_particles ( nn ) = pom_above * frac remin ( nn ) = pom_above - loc_particles ( nn ) else loc_particles ( nn ) = 0.0 remin ( nn ) = pom_above - loc_particles ( nn ) endif enddo endif !print*,n,loc_wc_end(n)-loc_wc_start(n),sum(remin(loc_wc_start(n):loc_wc_end(n))* & !loc_vol(loc_wc_start(n):loc_wc_end(n))) & !/sum(loc_vol(loc_wc_start(n):loc_wc_end(n))) - & !sum(loc_particles_copy(loc_wc_start(n):loc_wc_end(n))*loc_vol(loc_wc_start(n):loc_wc_end(n))) & !/sum(loc_vol(loc_wc_start(n):loc_wc_end(n))) enddo remin = amul_transpose ( Aconv , remin ) J (:, ioDIC ) = J (:, ioDIC ) + remin ! CaCO3 dissolution J (:, ioALK ) = J (:, ioALK ) + remin * 2.0 ! CO32- diag (:, 5 ) = remin ! loc_particles=amul(Aconv,particles(:,isCaCO3)) ! loc_particles=loc_particles*loc_vol ! mol m-3 -> mol ! ! remin=exp((120.0-loc_depth_btm)/bg_CaCO3_length_scale) ! ! do n=1,maxval(loc_wc) ! \tloc_remin_tot=0.0 ! \tloc_poc=0.0 ! \tloc_poc_copy=0.0 ! \tcount=1 ! \tdo nn=loc_wc_start(n),loc_wc_end(n) ! \t\tif(count.le.bg_n_euphotic_lyrs)then ! surface ! \t\t\tloc_poc=loc_poc+loc_particles(nn)! integrate POM in surface layers (mol) ! \t\t\tloc_particles(nn)=0.0 ! set flux to zero ! \t\t\tcount=count+1 ! \t\telseif(count.gt.bg_n_euphotic_lyrs)then ! interior ! \t\t\tloc_particles(nn)=(remin(nn-1)-remin(nn))*loc_poc ! \t\t\tloc_remin_tot=loc_remin_tot+(remin(nn-1)-remin(nn)) ! \t\t\tcount=count+1 ! \t\tendif ! ! \t\t! once reached the end of the wc, remin all remaining pom ! \t\tif(nn.eq.loc_wc_end(n)) loc_particles(nn)=loc_particles(nn)+(1.0-loc_remin_tot)*loc_poc ! ! \tenddo ! ! enddo ! ! loc_particles=loc_particles/loc_vol ! mol -> mol m-3 ! ! reorder particles array ! particles(:,isCaCO3)=amul_transpose(Aconv,loc_particles) ! ! ! ************* Update other tracers ********************** ! ! ! ! reorder particles array ! ! J(:,ioPO4)=J(:,ioPO4)+particles(:,isPOP) ! POP remineralisation ! ! diag(:,4)=particles(:,isPOP) ! ! diag(:,5)=particles(:,isCaCo3) ! J(:,ioPO4)=J(:,ioPO4)+particles(:,isPOP) ! POP remineralisation ! diag(:,4)=particles(:,isPOP) ! diag(:,5)=particles(:,isCaCo3) ! ! if(bg_C_select)then ! \t! OM remineralisation ! \tJ(:,ioDIC)=J(:,ioDIC)+(particles(:,isPOP)*bg_C_to_P) ! \tJ(:,ioALK)=J(:,ioALK)-(particles(:,isPOP)*bg_N_to_P) ! ! \t! CaCO3 dissolution ! \tJ(:,ioDIC)=J(:,ioDIC)+(particles(:,isCaCO3)) ! \tJ(:,ioALK)=J(:,ioALK)+(particles(:,isCaCO3)*2.0) ! endif end subroutine water_column end module bg_module","tags":"","loc":"sourcefile/bg_module.f90.html"},{"title":"fml.f90 – Fortran Matrix Lab","text":"This file depends on sourcefile~~fml.f90~~EfferentGraph sourcefile~fml.f90 fml.f90 sourcefile~io_module.f90 io_module.f90 sourcefile~fml.f90->sourcefile~io_module.f90 sourcefile~tm_module.f90 tm_module.f90 sourcefile~fml.f90->sourcefile~tm_module.f90 sourcefile~fml_lib.f90 fml_lib.f90 sourcefile~fml.f90->sourcefile~fml_lib.f90 sourcefile~bg_module.f90 bg_module.f90 sourcefile~fml.f90->sourcefile~bg_module.f90 sourcefile~io_module.f90->sourcefile~fml_lib.f90 sourcefile~tm_module.f90->sourcefile~io_module.f90 sourcefile~tm_module.f90->sourcefile~fml_lib.f90 sourcefile~bg_module.f90->sourcefile~tm_module.f90 sourcefile~bg_module.f90->sourcefile~fml_lib.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs fml Source Code fml.f90 Source Code PROGRAM fml ! ---------------------------------------------------------------------------------------! !! Main runtime !! - calls subroutines to set up model !! - sets up main timestep loop !! - calls biogeochemistry subroutines !! - calls subroutines to write model output ! ---------------------------------------------------------------------------------------! use fml_lib use tm_module use bg_module use io_module implicit none ! local variables integer :: n , nn , t , p , count , save_count !! various loop and counting indices real :: start , finish , sum_val , start2 , finish2 !! variables to track elapsed count = 0 save_count = 1 ! load user parameters call load_namelist () ! allocate arrays, assign parameter values call initialise_model () ! run simulation call cpu_time ( start ) do t = 1 , gen_runtime_years * tm_n_dt !do t=9990*tm_n_dt,gen_runtime_years*tm_n_dt J (:,:) = 0.0 particles (:,:) = 0.0 Jatm (:,:) = 0.0 call tm_vars_at_dt () call cpu_time ( start2 ) if ( mod ( t , int ( bg_dt_ratio )) == 0 ) THEN ! biogeochemistry source/sink if ( bg_C_select ) then call calc_C_consts () call calc_pCO2 () end if call PO4_uptake () !call POP_remin() call water_column () call DOP_remin () call calc_gasexchange () call restore_atm_CO2 () end if call timestep_fml () call integrate_output ( t , save_count , dt_count ) call cpu_time ( finish2 ) if ( mod ( t , tm_n_dt ) == 0.0 ) then call print_to_screen ( t , finish2 - start2 ) end if dt_count = dt_count + 1 ! revert timestep counter to zero if ( dt_count . gt . tm_n_dt ) then dt_count = 1 end if end do call cpu_time ( finish ) print * , '*************************' print * , 'Time taken =' , finish - start , 'seconds' print * , '*************************' print * , ! write output to netcdf file print * , '*************************' call write_restart () call write_PO4_uptake () print * , '*************************' END PROGRAM fml","tags":"","loc":"sourcefile/fml.f90.html"},{"title":"fml_lib.f90 – Fortran Matrix Lab","text":"Files dependent on this one sourcefile~~fml_lib.f90~~AfferentGraph sourcefile~fml_lib.f90 fml_lib.f90 sourcefile~io_module.f90 io_module.f90 sourcefile~io_module.f90->sourcefile~fml_lib.f90 sourcefile~tm_module.f90 tm_module.f90 sourcefile~tm_module.f90->sourcefile~fml_lib.f90 sourcefile~tm_module.f90->sourcefile~io_module.f90 sourcefile~fml.f90 fml.f90 sourcefile~fml.f90->sourcefile~fml_lib.f90 sourcefile~fml.f90->sourcefile~io_module.f90 sourcefile~fml.f90->sourcefile~tm_module.f90 sourcefile~bg_module.f90 bg_module.f90 sourcefile~fml.f90->sourcefile~bg_module.f90 sourcefile~bg_module.f90->sourcefile~fml_lib.f90 sourcefile~bg_module.f90->sourcefile~tm_module.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules fml_lib Source Code fml_lib.f90 Source Code module fml_lib ! ---------------------------------------------------------------------------------------! !! Namelist definitions of parameters !! !! - definitions of key parameters in model !! - default parameter values are set here !! - parameter values can be overriden by the user !! - loads user-defined parameters from experiment file ! ---------------------------------------------------------------------------------------! implicit none save ! ******************* namelist definitions ***********************! ! transport matrix parameters CHARACTER ( LEN = 100 ) :: tm_Aexp_filename , tm_Aimp_filename !! sparse matrix netCDF filename namelist / fml_namelist / tm_Aexp_filename , tm_Aimp_filename real :: tm_native_dt = 120 0.0 !! native timestep of transport matrix real :: tm_dt_scale = 1 !! multiplier to lengthen timestep namelist / fml_namelist / tm_native_dt , tm_dt_scale integer :: tm_n_dt !! number of timesteps integer :: tm_nbox !! number of wet grid-boxes in matrix grid namelist / fml_namelist / tm_n_dt , tm_nbox character ( len = 100 ) :: tm_PO4restore_filename , tm_PO4uptake_filename !! PO4 uptake forcing filenames namelist / fml_namelist / tm_PO4restore_filename , tm_PO4uptake_filename character ( len = 100 ) :: tm_bgc_data_filename = 'TMM_MIT_data.nc' !! filename of transport matrix metdata character ( len = 100 ) :: tm_grid_data_filename = 'TMM_MIT_grid.nc' !! filename of transport matrix grid data namelist / fml_namelist / tm_bgc_data_filename , tm_grid_data_filename logical :: tm_seasonal = . true . !! flag for seasonal transport matrices namelist / fml_namelist / tm_seasonal character ( len = 100 ) :: tm_data_fileloc !! location of transport matrix files namelist / fml_namelist / tm_data_fileloc logical :: tm_save_PO4_uptake = . false . !! flag to save PO4 uptake for fixed uptake namelist / fml_namelist / tm_save_PO4_uptake ! biogeochemical parameters real :: bg_uptake_tau = 3 0.0 !! michaelis-menten uptake rate (mol kg&#94;{-1} yr&#94;{-1}) namelist / fml_namelist / bg_uptake_tau real :: bg_DOC_k = 0.5 !! lifetime of dissolved organic matter (years) namelist / fml_namelist / bg_DOC_k real :: bg_dt_ratio = 1.0 !! biogeochemistry timestep ratio namelist / fml_namelist / bg_dt_ratio real :: bg_DOC_frac = 0.66 !! fraction of biological uptake to dissolved organic carbon namelist / fml_namelist / bg_DOC_frac integer :: bg_n_euphotic_lyrs = 2 !! number of vertical layers considered euphotic zone namelist / fml_namelist / bg_n_euphotic_lyrs character ( len = 100 ) :: bg_uptake_function = 'restore' !! biological uptake function namelist / fml_namelist / bg_uptake_function logical :: bg_O_select = . false . !! flag to select oxygen tracer namelist / fml_namelist / bg_O_select logical :: bg_C_select = . false . !! flag to select carbon tracers (DIC + ALK) namelist / fml_namelist / bg_C_select logical :: bg_restore_atm_CO2 = . false . !! flag to restore atmospheric CO2 namelist / fml_namelist / bg_restore_atm_CO2 real :: bg_restore_atm_CO2_target = 27 8.0 !! atmospheric CO2 value to restore to (mixing ratio) namelist / fml_namelist / bg_restore_atm_CO2_target real :: bg_gastransfer_a = 6.97e-7 !! gas transfer velocity (m s&#94;{-1}) namelist / fml_namelist / bg_gastransfer_a real :: bg_rain_ratio , bg_CaCO3_length_scale = 210 0.0 !! CaCO3 remineralisation length scale (m) namelist / fml_namelist / bg_rain_ratio , bg_CaCO3_length_scale real :: bg_martin_remin_b =- 0.858 !! Globally uniform Martin curve exponent (unitless) namelist / fml_namelist / bg_martin_remin_b logical :: bg_martin_remin_spatial = . false . !! flag to select spatially explicit Martin curves namelist / fml_namelist / bg_martin_remin_spatial character ( len = 100 ) :: bg_martin_b_input_filename = '' !! filename of spatially explicit Martin curve exponents namelist / fml_namelist / bg_martin_b_input_filename ! general model parameters integer :: gen_n_tracers = 2 !! number of tracers namelist / fml_namelist / gen_n_tracers integer :: gen_runtime_years = 1 !! runtime (years) namelist / fml_namelist / gen_runtime_years character ( len = 100 ) :: gen_save_timeseries_file !! filename containing savepoints for timeseries output character ( len = 100 ) :: gen_save_timeslice_file !! filename containing save points for netCDF output namelist / fml_namelist / gen_save_timeseries_file , gen_save_timeslice_file ! end of namelist definitions ! define sparse matrix type type sparse real , allocatable , dimension (:,:) :: val_n !! all transport matrix nonzeros real , allocatable , dimension (:) :: val !! interpolated nonzeros integer ( KIND = 4 ), allocatable , dimension (:) :: row !! row indices integer ( KIND = 4 ), allocatable , dimension (:) :: col !! column indices integer :: nnz !! number of nonzeros integer :: nb !! matrix dimensions (assumed square) integer :: n_time !! number of matrices end type sparse ! define the sparse matrices type ( sparse ) :: Aexp !! Explicit transport matrix type ( sparse ) :: Aimp !! Implicit transport matrix !type(sparse)::Aremin !type(sparse)::I ! identity matrix type ( sparse ) :: Aconv ! convert indices !! sparse matrix to convert indices type ( sparse ) :: Apow1 ! A**1 for set_TM_timestep() !! temporary sparse matrix for multiplying Aimp ! ******************* allocatable ***********************! real , dimension (:,:), allocatable :: tm_seaice_frac !! seaice fraction (fraction) real , dimension (:,:), allocatable :: tm_windspeed !! windspeed (m s&#94;{-1} real , dimension (:,:), allocatable :: tm_T !! temperature (deg C) real , dimension (:,:), allocatable :: tm_S !! salinity (PSU) real , dimension (:,:), allocatable :: tm_silica !! dissolved silica mol kg&#94;{-1} real , dimension (:), allocatable :: tm_area , tm_vol , tm_lon , tm_lat , tm_depth , tm_depth_btm !! grid variables integer , dimension (:), allocatable :: tm_i , tm_j , tm_k , tm_wc !! vector indies real , dimension (:), allocatable :: seaice_dt !! interpolated seaice real , dimension (:), allocatable :: wind_dt !! interpolated windspeed real , dimension (:), allocatable :: T_dt !! interpolated temperature real , dimension (:), allocatable :: S_dt !! interpolated salinity real , dimension (:), allocatable :: silica_dt !! interpolated dissolved silica real , dimension (:), allocatable :: bg_martin_b !! spatially explicit martin exponent real , dimension (:,:), allocatable :: bg_PO4_obs !! PO4 observations real , dimension (:,:), allocatable :: bg_PO4_uptake !! fixed PO4 uptake (mol kg&#94;{-1} yr&#94;{-1} real , dimension (:,:), allocatable :: tracers !! state variable array real , dimension (:,:), allocatable :: tracers_1 !! state variable array real , dimension (:,:), allocatable :: C !! carbonate chemistry array real , dimension (:,:), allocatable :: C_consts !! carbonate chemistry constants real , dimension (:,:), allocatable :: J !! source/sink real , dimension (:,:), allocatable :: Jatm !! sorce/sink for atmosphere real , dimension (:,:), allocatable :: particles !! particle array real , dimension (:), allocatable :: ATM !! atmosphere array real , dimension (:), allocatable :: export_save !! array to save export real , dimension (:,:), allocatable :: export_save_int !! array to save integrated export real , dimension (:,:), allocatable :: diag !! array of diagnosed quantities real , dimension (:,:), allocatable :: tracers_int !! state variables integrated over time period real , dimension (:), allocatable :: ATM_int !! atmosphere integrated over time period real :: t_int = 0.0 !! ? real , dimension (:,:), allocatable :: diag_int !! diagnosed quantities integrated over time period integer , dimension (:), allocatable :: iSur !! indices of surface real , dimension (:), allocatable :: tm_timeseries , tm_timeslice !! saving timepoints ! ******************* global variables ***********************! real :: gen_conv_d_yr = 36 5.25 !! convert days to years real :: bg_DOC_rfrac !! recipricol of bg_DOC_frac REAL :: bg_PO4_init = 0.00217 !! initial PO4 (mmol m-3 -> mol m-3) (Kriest et al., 2010) REAL :: bg_DOC_init = 0.0001 * 1 E - 03 !! inital DOP (mmol m-3 -> mol m-3) (Kriest et al., 2010) real :: bg_DIC_init = 2.299 !! initial DIC (mmol m-3 -> mol m-3) real :: bg_ALK_init = 2.420 !! initial Alkalinity (mmol m-3 -> mol m-3) real :: bg_dt !! biogeochemistry timestep (year) integer :: ioPO4 , ioDOP , ioDIC , ioALK !!indices integer :: ioCO2 , ioCO3 , ioH , iopCO2 !! indices integer :: iK1 , iK2 , iKw , iKp1 , iKp2 , iKp3 , iKSi , iKb , iK0 !! indices integer :: iaO2 , iaCO2 !! indices integer :: isPOP , isCaCO3 !! indices real , dimension (:), allocatable :: tm_seasonal_scale !! seasonal interpolation info real , dimension (:), allocatable :: tm_seasonal_rscale !! seasonal interpolation info integer , dimension (:), allocatable :: tm_seasonal_n1 !! seasonal interpolation info integer , dimension (:), allocatable :: tm_seasonal_n2 !! seasonal interpolation info integer :: dt_count !! counter for timesteps taken integer :: n_seasonal !! number of seasonal matrices integer :: n_euphotic_boxes !! number of vertical layers considered euphotic grid-boxes integer :: n_surface_boxes !! number of surface grid-boxes logical :: gen_restart_select = . false . !! flag to select restart character ( len = 100 ) :: gen_config_filename , gen_restart_filename real :: bg_C_to_P = 11 6.0 !! Redfield C:P real :: bg_N_to_P = 1 6.0 !! Redfield N:P real , dimension ( 5 , 2 ) :: Sc_coeffs ! 4 if using older values !! Schmidt number array for gas exchange real , dimension ( 6 , 2 ) :: Bunsen_coeffs !! Bunsen coefficients for gas exchange real , dimension ( 7 , 2 ) :: Sol_Orr !! solubility coefficients for gas exchange real :: conv_sec_yr = 6 0.0 * 6 0.0 * 2 4.0 * 36 5.25 !! convert seconds to years integer :: n_ATM_tracers real :: ATM_vol real :: ATM_mol real :: rho = 102 4.5 ! kg m-3 !! average density real :: r_rho = 1.0 / 102 4.5 ! m3 kg-1 !! recipricol of density real :: carbchem_tol = 0.01 !! tolerance for H+ convergence in carbonate chemistry subroutine real :: tm_save_intra_freq = 1.0 !! number of intra-year integration periods integer :: timeseries_count = 1 integer :: timeslice_count = 1 ! grid-dimensions: hard-coded! integer :: NZ = 15 ; integer :: NY = 64 ; integer :: NX = 128 ; real :: tm_dt contains ! ---------------------------------------------------------------------------------------! ! ---------------------------------------------------------------------------------------! subroutine load_namelist () ! ---------------------------------------------------------------------------------------! !! Load user-defined namelist parameters ! ---------------------------------------------------------------------------------------! ! local variables integer :: ios , nn , n , i character ( len = 100 ) :: arg ! read command line variables do i = 1 , iargc () CALL getarg ( i , arg ) if ( i . eq . 1 ) then gen_config_filename = arg ! config else if ( i . eq . 2 ) then read ( arg , * ) gen_runtime_years ! runtime else if ( i . eq . 3 ) then gen_restart_filename = arg ! restart gen_restart_select = . true . end if end do ! read in namelist file print * , trim ( gen_config_filename ) open ( unit = 20 , file = '../experiments/' // trim ( gen_config_filename ), status = 'old' , action = 'read' ) read ( unit = 20 , nml = fml_namelist , iostat = ios ) close ( unit = 20 ) end subroutine load_namelist ! ---------------------------------------------------------------------------------------! ! ---------------------------------------------------------------------------------------! end module fml_lib","tags":"","loc":"sourcefile/fml_lib.f90.html"},{"title":"tm_module.f90 – Fortran Matrix Lab","text":"This file depends on sourcefile~~tm_module.f90~~EfferentGraph sourcefile~tm_module.f90 tm_module.f90 sourcefile~io_module.f90 io_module.f90 sourcefile~tm_module.f90->sourcefile~io_module.f90 sourcefile~fml_lib.f90 fml_lib.f90 sourcefile~tm_module.f90->sourcefile~fml_lib.f90 sourcefile~io_module.f90->sourcefile~fml_lib.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~tm_module.f90~~AfferentGraph sourcefile~tm_module.f90 tm_module.f90 sourcefile~fml.f90 fml.f90 sourcefile~fml.f90->sourcefile~tm_module.f90 sourcefile~bg_module.f90 bg_module.f90 sourcefile~fml.f90->sourcefile~bg_module.f90 sourcefile~bg_module.f90->sourcefile~tm_module.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules tm_module Source Code tm_module.f90 Source Code module tm_module ! ---------------------------------------------------------------------------------------! !! Transport matrix related subroutines !! !! - initialise model !! - main timestepping subroutine !! - various matrix operations ! ---------------------------------------------------------------------------------------! use fml_lib use io_module implicit none contains ! ---------------------------------------------------------------------------------------! subroutine initialise_model () ! ---------------------------------------------------------------------------------------! !! Initialises FML model !! !! 1) sets up array indices !! !! 2) allocates arrays !! !! 3) loads in matrix data !! !! 4) initialises parameters !! !! 5) initialises arrays ! ---------------------------------------------------------------------------------------! ! local variables integer :: n character ( 8 ) :: date character ( 10 ) :: time character ( 5 ) :: zone integer , dimension ( 8 ) :: value ! print header text to screen call date_and_time ( date , time , zone , value ) print * , print * , '**************************' print * , '*** Fortran (Transport) Matrix Lab ***' print * , '**************************' print * , '' print '(1x,I4,A1,I2,A1,I2)' , value ( 1 ), '/' , value ( 2 ), '/' , value ( 3 ) print '(1x,I2,A1,I2,A1,I2)' , value ( 5 ), ':' , value ( 6 ), ':' , value ( 7 ) print * , '' print * , '*************************' print * , print * , 'Input Directory:' print * , '../data' // '/' // trim ( tm_data_fileloc ) PRINT * , if ( gen_restart_select ) then print * , 'Restart Directory:' print * , '../output/' // trim ( gen_restart_filename ) PRINT * , end if print * , 'Output Directory:' print * , '../output/' // trim ( gen_config_filename ) print * , print * , '*************************' print * , print * , 'Initialising model...' print * , ! -- set-up output files-- ! call load_data_saving () call initialise_output () ! -- set-up Transport Matrices -- ! call load_TM_metadata ( '../data' // '/' // trim ( tm_data_fileloc ) // '/' // trim ( tm_Aexp_filename ), Aexp ) call load_TM_metadata ( '../data' // '/' // trim ( tm_data_fileloc ) // '/' // trim ( tm_Aimp_filename ), Aimp ) allocate ( Aexp % val_n ( Aexp % nnz , Aexp % n_time )) allocate ( Aexp % val ( Aexp % nnz )) allocate ( Aexp % row ( Aexp % nb + 1 )) allocate ( Aexp % col ( Aexp % nnz )) allocate ( Aimp % val_n ( Aimp % nnz , Aimp % n_time )) allocate ( Aimp % val ( Aimp % nnz )) allocate ( Aimp % row ( Aimp % nb + 1 )) allocate ( Aimp % col ( Aimp % nnz )) call load_TM_netcdf ( '../data' // '/' // trim ( tm_data_fileloc ) // '/' // trim ( tm_Aexp_filename ), Aexp ) call load_TM_netcdf ( '../data' // '/' // trim ( tm_data_fileloc ) // '/' // trim ( tm_Aimp_filename ), Aimp ) call set_TM_timestep () tm_nbox = Aexp % nb n_seasonal = Aexp % n_time ! -- load Transport Matrid grid -- ! allocate ( tm_i ( tm_nbox )) allocate ( tm_j ( tm_nbox )) allocate ( tm_k ( tm_nbox )) allocate ( tm_lon ( tm_nbox )) allocate ( tm_lat ( tm_nbox )) allocate ( tm_depth ( tm_nbox )) allocate ( tm_depth_btm ( tm_nbox )) allocate ( tm_area ( tm_nbox )) allocate ( tm_vol ( tm_nbox )) allocate ( tm_wc ( tm_nbox )) call load_TM_grid_data () n_euphotic_boxes = 0 n_surface_boxes = 0 do n = 1 , tm_nbox if ( tm_k ( n ). le . bg_n_euphotic_lyrs ) n_euphotic_boxes = n_euphotic_boxes + 1 if ( tm_k ( n ). eq . 1 ) n_surface_boxes = n_surface_boxes + 1 end do call find_water_columns () allocate ( Aconv % val ( tm_nbox )) allocate ( Aconv % row ( tm_nbox + 1 )) allocate ( Aconv % col ( tm_nbox )) call create_Aconv () ! -- load boundary condition data -- ! allocate ( tm_T ( n_euphotic_boxes , n_seasonal )) allocate ( tm_S ( n_euphotic_boxes , n_seasonal )) allocate ( tm_silica ( n_euphotic_boxes , n_seasonal )) allocate ( bg_martin_b ( tm_nbox )) allocate ( tm_seaice_frac ( n_euphotic_boxes , n_seasonal )) allocate ( tm_windspeed ( n_euphotic_boxes , n_seasonal )) call load_TM_bgc_data () allocate ( seaice_dt ( n_euphotic_boxes )) allocate ( wind_dt ( n_euphotic_boxes )) allocate ( T_dt ( n_euphotic_boxes )) allocate ( S_dt ( n_euphotic_boxes )) allocate ( silica_dt ( n_euphotic_boxes )) ! -- set-up model arrays -- ! call calc_seasonal_scaling () ! tracer indices ioPO4 = 1 ioDOP = 2 ioDIC = 3 ioALK = 4 iK1 = 1 iK2 = 2 iK0 = 3 iKB = 4 iKw = 5 iKSi = 6 iKp1 = 7 iKp2 = 8 iKp3 = 9 ioCO2 = 1 ioCO3 = 2 ioH = 3 iopCO2 = 4 iaO2 = 1 iaCO2 = 2 isPOP = 1 isCaCO3 = 2 n_ATM_tracers = 2 ! n.b. 1 does not allow array operations !if(bg_O_select) n_ATM_tracers=n_ATM_tracers+1 !IF(bg_C_select) n_ATM_tracers=n_ATM_tracers+1 allocate ( tracers ( tm_nbox , gen_n_tracers )) allocate ( tracers_1 ( tm_nbox , gen_n_tracers )) allocate ( C ( tm_nbox , 4 )) allocate ( C_consts ( tm_nbox , 9 )) allocate ( ATM ( n_ATM_tracers )) allocate ( J ( tm_nbox , gen_n_tracers )) allocate ( Jatm ( n_surface_boxes , n_ATM_tracers )) allocate ( particles ( tm_nbox , gen_n_tracers )) allocate ( tracers_int ( tm_nbox , gen_n_tracers )) allocate ( ATM_int ( n_ATM_tracers )) allocate ( diag ( tm_nbox , 6 )) ! n.b. second dimension hard-coded currently allocate ( diag_int ( tm_nbox , 6 )) ! n.b. second dimension hard-coded currently ! if saving output for another run if ( tm_save_PO4_uptake ) then allocate ( export_save ( n_euphotic_boxes )) allocate ( export_save_int ( n_euphotic_boxes , tm_n_dt )) endif select case ( trim ( bg_uptake_function )) case ( 'restore' ) allocate ( bg_PO4_obs ( n_euphotic_boxes , n_seasonal )) case ( 'fixed' ) allocate ( bg_PO4_uptake ( n_euphotic_boxes , tm_n_dt )) end select ! -- initialise model arrays -- ! if ( gen_restart_select ) then call load_restart () else tracers_1 (:, ioPO4 ) = bg_PO4_init tracers_1 (:, ioDOP ) = bg_DOC_init tracers_1 (:, ioDIC ) = bg_DIC_init tracers_1 (:, ioALK ) = bg_ALK_init ATM ( iaCO2 ) = 27 8.0 * 1.0e-6 end if tracers (:,:) = 0.0 J (:,:) = 0.0 tracers_int (:,:) = 0.0 ATM_int (:) = 0.0 diag_int (:,:) = 0.0 Jatm (:,:) = 0.0 dt_count = 1 ! keep track of how many timesteps have passed in one year ! convert parameters to correct units bg_DOC_rfrac = 1.0 - bg_DOC_frac ! reciprical of DOC fraction !bg_DOC_k=1.0/bg_DOC_k ! year-1 bg_uptake_tau = ( 1.0 / bg_uptake_tau ) * gen_conv_d_yr ! days to years-1 !Sc_coeffs(:,iaO2)=(/1953.4 , 128.00 , 3.9918 , 0.050091/)   ! O2 !SC_coeffs(:,iaCO2)=(/2073.1 , 125.62 , 3.6276 , 0.043219/)   ! CO2 Sc_coeffs (:, iaCO2 ) = ( / 211 6.8 , - 13 6.25 , 4.7353 , - 0.092307 , 0.0007555 / ) ! CO2 Wanninkhof (2014), Orr et al., 2017, Table 1 SC_coeffs (:, iaO2 ) = ( / 192 0.4 , - 13 5.6 , 5.2122 , - 0.10939 , 0.00093777 / ) ! O2 Wanninkhof (2014), Orr et al., 2017, Table 1 Bunsen_coeffs (:, iaO2 ) = ( /- 5 8.3877 , 8 5.8079 , 2 3.8439 , - 0.034892 , 0.015568 , - 0.0019387 / ) ! O2 Bunsen_coeffs (:, iaCO2 ) = ( / - 6 0.2409 , 9 3.4517 , 2 3.3585 , 0.0023517 , - 0.023656 , 0.0047036 / ) ! CO2 Sol_Orr (:, iaCO2 ) = ( /- 16 0.7333 , 21 5.4152 , 8 9.8920 , - 1.47759 , 0.029941 , - 0.027455 , 0.0053407 / ) ! CO2, Orr et al., 2017, Table 2 !Sol_Orr(:,iaCO2)=Sol_Orr(:,iaCO2)*1000.0 ! mol L-1 atm-1 -> mol m-3 atm-1 (Orr et al., 2017, Table 2) !Sol_Orr(:,iaCO2)=(/-162.8301 , 218.2968 , 90.9241 , -1.47696 , 0.025695 , -0.025225 , 0.0049867/) ! CO2, Orr et al., 2017, Table 2 as mol kg-1 for checking ATM_vol = 777 7.0 * sum ( tm_area ( 1 : n_surface_boxes )) ! height (m) * total area (m2) ATM_mol = 1.77e20 ! ! temporary code C (:,:) =- 1.0 C_consts (:,:) = 0.0 !tm_T(:,:)=20.0 !tm_S(:,:)=30.0 !tm_windspeed(:,:)=0.0 !ATM(iaCO2)=278.0*1.0e-6 ! print final header print * , print * , '*************************' print * , print * , 'Running model...' print * , print * , '*************************' print * , print '(A7,A4,A7,A3,A8,A3,A5,A3,A8,A3,A9,A3)' , & '       ' , & 'year' , & '       ' , & 'PO4' , & '        ' , & 'DOP' , & '     ' , & 'DIC' , & '        ' , & 'ALK' , & '         ' , & 'CO2' call print_to_screen ( 0 , 0.0 ) end subroutine initialise_model ! ---------------------------------------------------------------------------------------! ! ---------------------------------------------------------------------------------------! subroutine set_TM_timestep () ! ---------------------------------------------------------------------------------------! !! Applies timestep to transport matrices ! ---------------------------------------------------------------------------------------! ! local variables integer :: n , nn real :: exponent , t ! Aexp = I+m(Aexp) Aexp % val_n = Aexp % val_n * tm_dt_scale * tm_native_dt do n = 1 , Aexp % nb do nn = Aexp % row ( n ), Aexp % row ( n + 1 ) - 1 if ( Aexp % col ( nn ). eq . n ) Aexp % val_n ( nn ,:) = 1.0 + Aexp % val_n ( nn ,:) end do end do ! allocate temporary Aimp copy ! Aimp accumulates results allocate ( Apow1 % val_n ( Aimp % nnz , Aimp % n_time )) allocate ( Apow1 % val ( Aimp % nnz )) allocate ( Apow1 % row ( Aimp % nb + 1 )) allocate ( Apow1 % col ( Aimp % nnz )) ! copy Aimp Apow1 % val_n = Aimp % val_n Apow1 % val = Aimp % val Apow1 % row = Aimp % row Apow1 % col = Aimp % col Apow1 % nnz = Aimp % nnz Apow1 % nb = Aimp % nb Apow1 % n_time = Aimp % n_time ! calculate Aimp**tm_dt_scale exponent = tm_dt_scale do t = mod ( exponent , 2.0 ) exponent = floor ( exponent / 2.0 ) if ( t . eq . 1.0 ) then call amub ( Aimp , Apow1 ) endif if ( exponent . eq . 0.0 ) then exit endif call amub ( Apow1 , Apow1 ) enddo ! deallocate temporary Aimp copy deallocate ( Apow1 % val_n ) deallocate ( Apow1 % val ) deallocate ( Apow1 % row ) deallocate ( Apow1 % col ) ! timestep tm_dt = tm_native_dt * tm_dt_scale * ( 1.0 / ( 6 0.0 * 6 0.0 * 2 4.0 * 36 0.0 )) ! yr bg_dt = tm_dt * bg_dt_ratio ! BGC timestep tm_n_dt = nint ( 1.0 / tm_dt ) end subroutine set_TM_timestep ! ---------------------------------------------------------------------------------------! ! ---------------------------------------------------------------------------------------! subroutine calc_seasonal_scaling ! ---------------------------------------------------------------------------------------! !! Calculates indices for interpolating the seasonal transport matrices ! ---------------------------------------------------------------------------------------! ! local variables integer :: n , count , nn , n_dt_season if ( tm_seasonal ) then n_seasonal = 12 else n_seasonal = 1 end if allocate ( tm_seasonal_scale ( tm_n_dt )) allocate ( tm_seasonal_rscale ( tm_n_dt )) allocate ( tm_seasonal_n1 ( tm_n_dt )) allocate ( tm_seasonal_n2 ( tm_n_dt )) tm_seasonal_n1 = 0.0 tm_seasonal_n2 = 0.0 if ( tm_seasonal ) then n_dt_season = int ( real ( tm_n_dt ) / real ( 12 )) count = 1 do n = 1 , tm_n_dt , n_dt_season do nn = 0 ,( n_dt_season ) - 1 tm_seasonal_n1 ( n + nn ) = count tm_seasonal_n2 ( n + nn ) = count + 1 end do count = count + 1 end do where ( tm_seasonal_n2 == 13 ) tm_seasonal_n2 = 1 do n = 1 , tm_n_dt , n_dt_season DO nn = 0 ,( n_dt_season ) - 1 tm_seasonal_rscale ( nn + n ) = real ( nn ) / ( real ( n_dt_season ) - 1 ) tm_seasonal_scale ( nn + n ) = 1.0 - tm_seasonal_rscale ( nn + n ) end do end do else count = 1 do n = 1 , tm_n_dt tm_seasonal_n1 ( n ) = count tm_seasonal_n2 ( n ) = count tm_seasonal_scale ( n ) = 1.0 tm_seasonal_rscale ( n ) = 1.0 - tm_seasonal_scale ( n ) end do end if !print*,'n1',tm_seasonal_n1 !print*,'n2',tm_seasonal_n2 !print*,'scale',tm_seasonal_scale !print*,'rscale',tm_seasonal_rscale !~ ! local variables !~ integer::n,count,nn !~ integer,dimension(13)::jul_cumdays !~ real,dimension(12)::jul_days !~ real::n_days,sum_val !~ n_days=1.0/((1.0/tm_n_dt)*365) ! number of days per timestep !~ jul_days=(/31,28,31,30,31,30,31,31,30,31,30,31/)*int(n_days) ! julian days !~ ! create indices !~ jul_cumdays(1)=1 !~ sum_val=1 !~ do n=2,13 !~ sum_val=sum_val+jul_days(n-1) !~ jul_cumdays(n)=sum_val !~ end do !~ if(tm_seasonal)then !~ n_seasonal=12 !~ else !~ n_seasonal=1 !~ end if !~ allocate(tm_seasonal_scale(tm_n_dt)) !~ allocate(tm_seasonal_rscale(tm_n_dt)) !~ allocate(tm_seasonal_n1(tm_n_dt)) !~ allocate(tm_seasonal_n2(tm_n_dt)) !~ tm_seasonal_n1=0.0 !~ tm_seasonal_n2=0.0 !~ if(tm_seasonal)then !~ count=1 !~ do n=1,12 !~ do nn=jul_cumdays(n),jul_cumdays(n+1)-1 !~ tm_seasonal_n1(nn)=count !~ tm_seasonal_n2(nn)=count+1 !~ end do !~ count=count+1 !~ end do !~ where(tm_seasonal_n2==13) tm_seasonal_n2=1 !~ sum_val=0.0 !~ do n=1,12 !~ do nn=jul_cumdays(n),jul_cumdays(n+1)-1 !~ tm_seasonal_rscale(nn)=sum_val !~ sum_val=sum_val+(1.0/jul_days(n)) !~ end do !~ sum_val=0.0 !~ end do !~ tm_seasonal_scale=1.0-tm_seasonal_rscale !~ else !~ count=1 !~ do n=1,tm_n_dt !~ tm_seasonal_n1(n)=count !~ tm_seasonal_n2(n)=count !~ tm_seasonal_scale(n)=1.0 !~ tm_seasonal_rscale(n)=1.0-tm_seasonal_scale(n) !~ end do !~ end if end subroutine calc_seasonal_scaling ! ---------------------------------------------------------------------------------------! ! ---------------------------------------------------------------------------------------! subroutine timestep_fml () ! ---------------------------------------------------------------------------------------! !! Integrate model forward in time !! !! - integrates model forward in time using fixed timesteps !! !! - calculates  \\mathbf{A_{imp}} * ( \\mathbf{A_{exp}}*\\mathbf{c}+\\mathbf{q})  where: !! !! \\mathbf{A_{imp}} - implicit matrix !! !! \\mathbf{A_{exp}} - explicit matrix !! !! \\mathbf{c} - state variable vector !! !! \\mathbf{q} - source/sink vector ! ---------------------------------------------------------------------------------------! integer :: n ! explicit step (Aexp*C) do n = 1 , gen_n_tracers tracers (:, n ) = amul ( Aexp , tracers_1 (:, n )) enddo ! source/sinks (+q) tracers (:,:) = tracers (:,:) + J (:,:) * bg_dt ATM ( iaCO2 ) = ATM ( iaCO2 ) + sum ( Jatm (:, iaCO2 )) * bg_dt / ATM_mol ! implicit step (Aimp*...) do n = 1 , gen_n_tracers tracers (:, n ) = amul ( Aimp , tracers (:, n )) enddo tracers_1 = tracers end subroutine timestep_fml ! ---------------------------------------------------------------------------------------! ! ---------------------------------------------------------------------------------------! ! FUNCTION amul(A,Vector) ! ! output ! REAL,dimension(tm_nbox,gen_n_tracers)::amul ! ! dummy ! type(sparse),intent(in)::A ! REAL,INTENT(in),dimension(tm_nbox,gen_n_tracers)::Vector ! ! local ! integer::n,nn,i ! real::sum_val ! integer,dimension(2)::vector_size ! real,dimension(A%nnz)::val_tmp ! ! vector_size=shape(Vector) ! ! val_tmp=(tm_seasonal_scale(dt_count)*A%val(:,tm_seasonal_n1(dt_count)))& ! +& ! ((tm_seasonal_rscale(dt_count))*A%val(:,tm_seasonal_n2(dt_count))) ! ! DO i=1,vector_size(2) ! do n=1,tm_nbox ! \tsum_val=0.0 ! ! \tdo nn=A%row(n),A%row(n+1)-1 ! \t\tsum_val=sum_val+val_tmp(nn)*Vector(A%col(nn),i) ! \tend do ! \tamul(n,i)=sum_val ! end do ! end do ! ! end FUNCTION ! ---------------------------------------------------------------------------------------! ! ---------------------------------------------------------------------------------------! ! FUNCTION amul_remin(A,Vector) ! ! output ! REAL,dimension(tm_nbox)::amul_remin ! ! dummy ! type(sparse),intent(in)::A ! REAL,INTENT(in),dimension(tm_nbox)::Vector ! ! local ! integer::n,nn,i ! real::sum_val ! ! ! do n=1,tm_nbox ! \tsum_val=0.0 ! ! \tdo nn=A%row(n),A%row(n+1)-1 ! \t\tsum_val=sum_val+A%val(nn,1)*Vector(A%col(nn)) ! \t\t!print*,nn,A%row(n),A%row(n+1)-1,A%val(nn,1),Vector(A%col(nn)) ! \tend do ! \tamul_remin(n)=sum_val ! end do ! !stop ! ! end FUNCTION ! ---------------------------------------------------------------------------------------! ! ---------------------------------------------------------------------------------------! FUNCTION amul ( A , vector ) ! ---------------------------------------------------------------------------------------! !! sparse matrix - vector multiplication (CSR format) !! !! adapted from SPARSEKIT (https://people.sc.fsu.edu/~jburkardt/f_src/sparsekit/sparsekit.html) ! ---------------------------------------------------------------------------------------! ! output REAL , dimension ( tm_nbox ) :: amul ! dummy type ( sparse ), intent ( in ) :: A !! sparse matrix REAL , INTENT ( in ), dimension ( tm_nbox ) :: vector !! vector ! local integer :: n , nn real :: sum_val do n = 1 , size ( vector ) sum_val = 0.0 do nn = A % row ( n ), A % row ( n + 1 ) - 1 sum_val = sum_val + A % val ( nn ) * vector ( A % col ( nn )) end do amul ( n ) = sum_val end do end FUNCTION ! ---------------------------------------------------------------------------------------! ! ---------------------------------------------------------------------------------------! FUNCTION amul_transpose ( A , vector ) ! ---------------------------------------------------------------------------------------! !! transpose sparse matrix - vector multiplication (CSR format) !! !! adapted from SPARSEKIT (https://people.sc.fsu.edu/~jburkardt/f_src/sparsekit/sparsekit.html) ! ---------------------------------------------------------------------------------------! ! output REAL , dimension ( tm_nbox ) :: amul_transpose ! dummy type ( sparse ), intent ( in ) :: A !! sparse matrix REAL , INTENT ( in ), dimension ( tm_nbox ) :: vector !! vector ! local integer :: n , nn , i real :: sum_val real , dimension ( tm_nbox ) :: tmp amul_transpose = 0.0 do n = 1 , size ( vector ) do nn = A % row ( n ), A % row ( n + 1 ) - 1 amul_transpose ( A % col ( nn )) = amul_transpose ( A % col ( nn )) + Vector ( n ) * A % val ( nn ) end do end do end FUNCTION ! ---------------------------------------------------------------------------------------! ! ---------------------------------------------------------------------------------------! function amub_nnz ( A , B ) ! ---------------------------------------------------------------------------------------! !! sparse matrix multiplication (CSR format): find nonzeros !! !! adapted from SPARSEKIT (https://people.sc.fsu.edu/~jburkardt/f_src/sparsekit/sparsekit.html) ! ---------------------------------------------------------------------------------------! ! output integer :: amub_nnz ! dummy type ( sparse ), intent ( in ) :: A !! sparse matrix type ( sparse ), intent ( in ) :: B !! sparse matrix ! local integer :: ncol integer :: ncolb integer :: nrow integer :: ii integer , dimension ( size ( A % row ) - 1 ) :: iw integer :: j integer :: jc integer :: jr integer :: k integer :: last integer :: ldg integer , dimension ( size ( A % row ) - 1 ) :: ndegr ! assuming square matrices of same size ncol = size ( A % row ) - 1 ncolb = size ( A % row ) - 1 nrow = size ( A % row ) - 1 iw ( 1 : ncolb ) = 0 ndegr ( 1 : nrow ) = 0 do ii = 1 , nrow ! !  For each row of A. ! ldg = 0 ! !  End-of-linked list. ! last = - 1 do j = A % row ( ii ), A % row ( ii + 1 ) - 1 ! !  Row number to be added. ! jr = A % col ( j ) do k = B % row ( jr ), B % row ( jr + 1 ) - 1 jc = B % col ( k ) ! !  Add one element to the linked list. ! if ( iw ( jc ) == 0 ) then ldg = ldg + 1 iw ( jc ) = last last = jc end if end do end do ndegr ( ii ) = ldg ! !  Reset IW to zero. ! do k = 1 , ldg j = iw ( last ) iw ( last ) = 0 last = j end do end do ! output nnz of A*B amub_nnz = sum ( ndegr ( 1 : nrow ) ) end function ! ---------------------------------------------------------------------------------------! ! ---------------------------------------------------------------------------------------! subroutine amub ( A , B ) ! ---------------------------------------------------------------------------------------! !! sparse matrix multiplication A*B (CSR format) !! !! assumes square Matrix !! !! writes result to matrix A !! !! adapted from SPARSEKIT (https://people.sc.fsu.edu/~jburkardt/f_src/sparsekit/sparsekit.html) ! ---------------------------------------------------------------------------------------! ! dummy type ( sparse ), intent ( inout ) :: A !! sparse matrix type ( sparse ), intent ( in ) :: B !! sparse matrix ! local integer :: n , nn , i , s real :: sum_val real , dimension ( A % nb ) :: tmp integer :: len integer :: ierr integer , dimension ( A % nb ) :: iw integer :: ka , ii , kb , jj , k integer :: jcol , jpos real :: scal integer :: nzmax , ncol , nrow integer , dimension ( size ( A % row )) :: ic integer , allocatable , dimension (:) :: jc real , allocatable , dimension (:,:) :: c ncol = A % nb ! size of col (assumes square matrix) nrow = A % nb ! size of row (assumes square matrix) ! find nnz's of new matrix nzmax = amub_nnz ( A , B ) ! allocate working arrays allocate ( jc ( nzmax )) allocate ( c ( nzmax , A % n_time )) do s = 1 , A % n_time len = 0 ic ( 1 ) = 1 ! !  Initialize IW. ! iw ( 1 : ncol ) = 0 do ii = 1 , nrow ! !  Row I. ! do ka = A % row ( ii ), A % row ( ii + 1 ) - 1 scal = A % val_n ( ka , s ) jj = B % col ( ka ) do kb = B % row ( jj ), B % row ( jj + 1 ) - 1 jcol = B % col ( kb ) jpos = iw ( jcol ) if ( jpos == 0 ) then len = len + 1 if ( nzmax < len ) then ierr = ii return end if jc ( len ) = jcol iw ( jcol ) = len c ( len , s ) = scal * B % val_n ( kb , s ) else c ( jpos , s ) = c ( jpos , s ) + scal * B % val_n ( kb , s ) end if end do end do do k = ic ( ii ), len iw ( jc ( k )) = 0 end do ic ( ii + 1 ) = len + 1 end do end do ! seasonal loop ! set A to C=A*B if ( nzmax . ne . B % nnz ) then ! deallocate(A%val_n) ! deallocate(A%col) ! ! allocate(A%val_n(nzmax,A%n_time)) ! allocate(A%col(nzmax)) print * , 'fatal error - A*B results in different number of nonzeros' stop end if A % val_n = c A % col = jc A % row = ic A % nnz = nzmax !deallocate(c) !deallocate(jc) end subroutine amub ! ---------------------------------------------------------------------------------------! ! aplb ! - matrix + matrix (CSR Format) ! - adapted from SPARSEKIT (https://people.sc.fsu.edu/~jburkardt/f_src/sparsekit/sparsekit.html) ! ---------------------------------------------------------------------------------------! ! FUNCTION aplb(A,B) ! ! output ! type(sparse),intent(inout)::amplb ! ! dummy ! type(sparse),intent(in)::A ! type(sparse),intent(in)::B ! ! local ! integer::n,nn,i ! real::sum_val ! real,dimension(tm_nbox)::tmp ! ! integer::len ! integer,dimension(size(A%row))::ic ! integer,dimension(tm_nbox)::iw ! integer::ka,ii,kb,jj,k ! real::scal ! integer::nzmax,ncol,nrow ! ! nzmax=size(A%val) ! number of nnz's ! ncol=tm_nbox ! size of col (assumes square matrix) ! nrow=tm_nbox ! size of row (assumes square matrix) ! ! ierr = 0 ! len = 0 ! ic(1) = 1 ! iw(1:ncol) = 0 ! ! do ii = 1, nrow ! ! ! !  Row I. ! ! ! \t do ka = A%row(ii), A%row(ii+1)-1 ! ! \t\t\tlen = len + 1 ! \t\t\tjcol = A%col(ka) ! ! \t\t\tif ( nzmax < len ) then ! \t\t\t\tierr = ii ! \t\t\t\treturn ! \t\t\tend if ! ! \t\t\taplb%col(len) = jcol ! \t\t\taplb%val(len) = A%val(ka) ! \t\t\tiw(jcol) = len ! \t end do ! ! \t do kb = B%row(ii), B%row(ii+1)-1 ! ! \t\t\tjcol = B%col(kb) ! \t\t\tjpos = iw(jcol) ! ! \t\t\tif ( jpos == 0 ) then ! ! \t\t\t\t len = len + 1 ! ! \t\t\t\t if ( nzmax < len ) then ! \t\t\t\t\t ierr = ii ! \t\t\t\t\t return ! \t\t\t\t end if ! ! \t\t\t\t aplb%col(len) = jcol ! \t\t\t\t aplb%val(len) = B%val(kb) ! \t\t\t\t iw(jcol)= len ! \t\t\telse ! \t\t\t\t aplb%val(jpos) = aplb%val(jpos) + B%val(kb) ! \t\t\tend if ! ! \t end do ! ! \t do k = aplb%row(ii), len ! \t\t iw(aplb%col(k)) = 0 ! \t end do ! ! \t aplb%row(ii+1) = len+1 ! end do ! ! return ! end ! ! end function aplb ! ---------------------------------------------------------------------------------------! ! ---------------------------------------------------------------------------------------! subroutine print_to_screen ( dum_t , dum_extra ) ! ---------------------------------------------------------------------------------------! !! Print output to screen during runtime ! ---------------------------------------------------------------------------------------! integer :: dum_t !! timestep real :: dum_extra !! not used ! local real :: vol_rtot vol_rtot = 1.0 / sum ( tm_vol ) print '(F11.2,F11.2,F11.2,F11.2,F11.2,F11.2)' , & real ( dum_t / tm_n_dt ), & sum ( tracers_1 (:, ioPO4 ) * tm_vol ) * vol_rtot * 1.0e3 , & sum ( tracers_1 (:, ioDOP ) * tm_vol ) * vol_rtot * 1.0e3 , & sum ( tracers_1 (:, ioDIC ) * tm_vol ) * vol_rtot * 1.0e3 , & sum ( tracers_1 (:, ioALK ) * tm_vol ) * vol_rtot * 1.0e3 , & ATM ( iaCO2 ) * 1.0e6 end subroutine print_to_screen ! ---------------------------------------------------------------------------------------! ! ---------------------------------------------------------------------------------------! subroutine tm_vars_at_dt () ! ---------------------------------------------------------------------------------------! !! Linearly interpolate seaice, windstress, T, S at current timestep ! ---------------------------------------------------------------------------------------! seaice_dt = ( tm_seasonal_scale ( dt_count ) * tm_seaice_frac (:, tm_seasonal_n1 ( dt_count ))) & + & (( tm_seasonal_rscale ( dt_count )) * tm_seaice_frac (:, tm_seasonal_n2 ( dt_count ))) wind_dt = ( tm_seasonal_scale ( dt_count ) * tm_windspeed (:, tm_seasonal_n1 ( dt_count ))) & + & (( tm_seasonal_rscale ( dt_count )) * tm_windspeed (:, tm_seasonal_n2 ( dt_count ))) T_dt = ( tm_seasonal_scale ( dt_count ) * tm_T (:, tm_seasonal_n1 ( dt_count ))) & + & (( tm_seasonal_rscale ( dt_count )) * tm_T (:, tm_seasonal_n2 ( dt_count ))) S_dt = ( tm_seasonal_scale ( dt_count ) * tm_S (:, tm_seasonal_n1 ( dt_count ))) & + & (( tm_seasonal_rscale ( dt_count )) * tm_S (:, tm_seasonal_n2 ( dt_count ))) silica_dt = ( tm_seasonal_scale ( dt_count ) * tm_silica (:, tm_seasonal_n1 ( dt_count ))) & + & (( tm_seasonal_rscale ( dt_count )) * tm_silica (:, tm_seasonal_n2 ( dt_count ))) ! convert wind_dt to correct units for gas exchange ! not pre-calculated due to non-linear terms (u&#94;2) ! *** windspeed is m/s? so adjust this line of code *** ! !print*,'wind m s-1',wind_dt(2000),seaice_dt(2000) wind_dt = ( wind_dt * wind_dt ) * bg_gastransfer_a * seaice_dt * conv_sec_yr ! seasonal matrix values Aexp % val = ( tm_seasonal_scale ( dt_count ) * Aexp % val_n (:, tm_seasonal_n1 ( dt_count ))) & + & (( tm_seasonal_rscale ( dt_count )) * Aexp % val_n (:, tm_seasonal_n2 ( dt_count ))) Aimp % val = ( tm_seasonal_scale ( dt_count ) * Aimp % val_n (:, tm_seasonal_n1 ( dt_count ))) & + & (( tm_seasonal_rscale ( dt_count )) * Aimp % val_n (:, tm_seasonal_n2 ( dt_count ))) end subroutine tm_vars_at_dt ! ---------------------------------------------------------------------------------------! ! ---------------------------------------------------------------------------------------! subroutine integrate_output ( loc_t , loc_save_count , loc_dt_count ) ! ---------------------------------------------------------------------------------------! !! Average output and write to files if appropriate ! ---------------------------------------------------------------------------------------! integer , intent ( in ) :: loc_t !! timestep integer , intent ( inOUT ) :: loc_save_count !! counter to keep track of number of save intervals integer , intent ( in ) :: loc_dt_count !! number of timesteps through averaging interval ! local real :: scalar !if(loc_t>=tm_timeseries(timeseries_count)*96-47 .and. loc_t<=tm_timeseries(timeseries_count)*96+48)then ! integrate scalar = bg_dt * tm_save_intra_freq tracers_int (:,:) = tracers_int (:,:) + tracers (:,:) * scalar ATM_int (:) = ATM_int (:) + ATM (:) * scalar t_int = t_int + (( loc_t - 1.0 ) / ( 1.0 / bg_dt )) * scalar diag_int = diag_int + diag (:,:) * scalar if ( loc_dt_count . eq . tm_n_dt ) then ! at end of model year if ( loc_t == tm_timeseries ( timeseries_count ) * 96 + 48 ) then ! if within a timeseries save year call write_timeseries_output () timeseries_count = timeseries_count + 1 endif if ( loc_t == tm_timeslice ( timeslice_count ) * 96 + 48 ) then ! if within a timeslice save year call write_output_netcdf () timeslice_count = timeslice_count + 1 endif ! write when reached end of time period ! and reset integrating arrays !if(loc_t==tm_timeseries(timeseries_count)*96+48)then ATM_int (:) = 0.0 tracers_int (:,:) = 0.0 t_int = 0.0 diag_int = 0.0 endif ! within the last model year, save export if ( tm_save_PO4_uptake ) then ! if(loc_t>=(gen_runtime_years*tm_n_dt)-95 .and. loc_t<=(gen_runtime_years*tm_n_dt))then ! if within final year ! \texport_save_int(:,loc_save_count)=export_save_int(:,loc_save_count)+export_save(:)*bg_dt*(real(tm_n_dt)/real(n_seasonal)) ! ! \tif(mod(real(loc_dt_count),real(tm_n_dt)/real(n_seasonal)).eq.0.0)then ! step through seasons ! \t\tloc_save_count=loc_save_count+1 ! \tendif ! ! endif if ( loc_t >= ( gen_runtime_years * tm_n_dt ) - 95 . and . loc_t <= ( gen_runtime_years * tm_n_dt )) then ! if within final year export_save_int (:, loc_save_count ) = export_save (:) loc_save_count = loc_save_count + 1 endif endif end subroutine integrate_output ! ---------------------------------------------------------------------------------------! ! ---------------------------------------------------------------------------------------! subroutine find_water_columns () ! ---------------------------------------------------------------------------------------! !! Creates index of water columns in model grid ! ---------------------------------------------------------------------------------------! integer :: n , nn integer :: i , j do n = 1 , n_surface_boxes do nn = 1 , tm_nbox i = tm_i ( n ) j = tm_j ( n ) if ( tm_i ( nn ). eq . i . and . tm_j ( nn ). eq . j ) tm_wc ( nn ) = n enddo enddo end subroutine find_water_columns ! ---------------------------------------------------------------------------------------! ! ---------------------------------------------------------------------------------------! subroutine create_Aconv () ! ---------------------------------------------------------------------------------------! !! Creates a sparse matrix that re-orders vectors to water-column order for remin subroutines ! ---------------------------------------------------------------------------------------! integer :: n , nn , count integer , dimension ( tm_nbox ) :: tmp , tmp2 count = 1 do n = 1 , n_surface_boxes do nn = 1 , tm_nbox if ( tm_wc ( nn ) == n ) then Aconv % val ( count ) = 1.0 Aconv % col ( count ) = nn Aconv % row ( count ) = count count = count + 1 endif enddo enddo Aconv % row ( count ) = count end subroutine create_Aconv end module tm_module","tags":"","loc":"sourcefile/tm_module.f90.html"},{"title":"sparse – Fortran Matrix Lab ","text":"type, public :: sparse Contents Variables val_n val row col nnz nb n_time Components Type Visibility Attributes Name Initial real, public, allocatable, dimension(:,:) :: val_n all transport matrix nonzeros real, public, allocatable, dimension(:) :: val interpolated nonzeros integer(kind=4), public, allocatable, dimension(:) :: row row indices integer(kind=4), public, allocatable, dimension(:) :: col column indices integer, public :: nnz number of nonzeros integer, public :: nb matrix dimensions (assumed square) integer, public :: n_time number of matrices","tags":"","loc":"type/sparse.html"},{"title":"v2f – Fortran Matrix Lab","text":"public function v2f(vector) reorder vector into a 3D field Arguments Type Intent Optional Attributes Name real, dimension(tm_nbox) :: vector Return Value real,\n  dimension(NX,NY,NZ) Called by proc~~v2f~~CalledByGraph proc~v2f v2f proc~write_output_netcdf write_output_netcdf proc~write_output_netcdf->proc~v2f proc~integrate_output integrate_output proc~integrate_output->proc~write_output_netcdf program~fml fml program~fml->proc~integrate_output Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/v2f.html"},{"title":"load_TM_data – Fortran Matrix Lab","text":"public subroutine load_TM_data() Arguments None Calls proc~~load_tm_data~~CallsGraph proc~load_tm_data load_TM_data proc~load_po4_uptake load_PO4_uptake proc~load_tm_data->proc~load_po4_uptake proc~load_tm_bgc_data load_TM_bgc_data proc~load_tm_data->proc~load_tm_bgc_data proc~load_martin_b_spatial load_Martin_b_spatial proc~load_tm_data->proc~load_martin_b_spatial proc~load_po4_restore load_PO4_restore proc~load_tm_data->proc~load_po4_restore proc~load_tm_grid_data load_TM_grid_data proc~load_tm_data->proc~load_tm_grid_data nf90_close nf90_close proc~load_tm_bgc_data->nf90_close nf90_strerror nf90_strerror proc~load_tm_bgc_data->nf90_strerror nf90_inq_varid nf90_inq_varid proc~load_tm_bgc_data->nf90_inq_varid nf90_open nf90_open proc~load_tm_bgc_data->nf90_open nf90_get_var nf90_get_var proc~load_tm_bgc_data->nf90_get_var proc~load_martin_b_spatial->nf90_close proc~load_martin_b_spatial->nf90_strerror proc~load_martin_b_spatial->nf90_inq_varid proc~load_martin_b_spatial->nf90_open proc~load_martin_b_spatial->nf90_get_var proc~load_po4_restore->nf90_close proc~load_po4_restore->nf90_strerror proc~load_po4_restore->nf90_inq_varid proc~load_po4_restore->nf90_open proc~load_po4_restore->nf90_get_var proc~load_tm_grid_data->nf90_close proc~load_tm_grid_data->nf90_strerror proc~load_tm_grid_data->nf90_inq_varid proc~load_tm_grid_data->nf90_open proc~load_tm_grid_data->nf90_get_var Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/load_tm_data.html"},{"title":"load_TM_netcdf – Fortran Matrix Lab","text":"public subroutine load_TM_netcdf(dum_filename, dum_A) Loads transport matrix data from netCDF files Arguments Type Intent Optional Attributes Name character(len=*) :: dum_filename netCDF filename type( sparse ) :: dum_A sparse matrix arrays Calls proc~~load_tm_netcdf~~CallsGraph proc~load_tm_netcdf load_TM_netcdf nf90_close nf90_close proc~load_tm_netcdf->nf90_close nf90_strerror nf90_strerror proc~load_tm_netcdf->nf90_strerror nf90_inq_varid nf90_inq_varid proc~load_tm_netcdf->nf90_inq_varid nf90_open nf90_open proc~load_tm_netcdf->nf90_open nf90_get_var nf90_get_var proc~load_tm_netcdf->nf90_get_var Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/load_tm_netcdf.html"},{"title":"load_TM_metadata – Fortran Matrix Lab","text":"public subroutine load_TM_metadata(dum_filename, dum_A) Loads transport matrix metadata from netCDF file Arguments Type Intent Optional Attributes Name character(len=*) :: dum_filename netCDF filename type( sparse ) :: dum_A sparse matrix arrays Calls proc~~load_tm_metadata~~CallsGraph proc~load_tm_metadata load_TM_metadata nf90_close nf90_close proc~load_tm_metadata->nf90_close nf90_strerror nf90_strerror proc~load_tm_metadata->nf90_strerror nf90_inq_varid nf90_inq_varid proc~load_tm_metadata->nf90_inq_varid nf90_open nf90_open proc~load_tm_metadata->nf90_open nf90_get_var nf90_get_var proc~load_tm_metadata->nf90_get_var Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/load_tm_metadata.html"},{"title":"load_TM_grid_data – Fortran Matrix Lab","text":"public subroutine load_TM_grid_data() Loads transport matrix grid data from netCDF file Arguments None Calls proc~~load_tm_grid_data~~CallsGraph proc~load_tm_grid_data load_TM_grid_data nf90_close nf90_close proc~load_tm_grid_data->nf90_close nf90_strerror nf90_strerror proc~load_tm_grid_data->nf90_strerror nf90_inq_varid nf90_inq_varid proc~load_tm_grid_data->nf90_inq_varid nf90_open nf90_open proc~load_tm_grid_data->nf90_open nf90_get_var nf90_get_var proc~load_tm_grid_data->nf90_get_var Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~load_tm_grid_data~~CalledByGraph proc~load_tm_grid_data load_TM_grid_data proc~initialise_model initialise_model proc~initialise_model->proc~load_tm_grid_data proc~load_tm_data load_TM_data proc~load_tm_data->proc~load_tm_grid_data program~fml fml program~fml->proc~initialise_model Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/load_tm_grid_data.html"},{"title":"load_TM_bgc_data – Fortran Matrix Lab","text":"public subroutine load_TM_bgc_data() Loads transport matrix biogeochemistry data from netCDF file Arguments None Calls proc~~load_tm_bgc_data~~CallsGraph proc~load_tm_bgc_data load_TM_bgc_data nf90_close nf90_close proc~load_tm_bgc_data->nf90_close nf90_strerror nf90_strerror proc~load_tm_bgc_data->nf90_strerror nf90_inq_varid nf90_inq_varid proc~load_tm_bgc_data->nf90_inq_varid nf90_open nf90_open proc~load_tm_bgc_data->nf90_open nf90_get_var nf90_get_var proc~load_tm_bgc_data->nf90_get_var Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~load_tm_bgc_data~~CalledByGraph proc~load_tm_bgc_data load_TM_bgc_data proc~initialise_model initialise_model proc~initialise_model->proc~load_tm_bgc_data proc~load_tm_data load_TM_data proc~load_tm_data->proc~load_tm_bgc_data program~fml fml program~fml->proc~initialise_model Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/load_tm_bgc_data.html"},{"title":"load_PO4_restore – Fortran Matrix Lab","text":"public subroutine load_PO4_restore() Loads [PO4] observations from netCDF file for nutrient restoring subroutine Arguments None Calls proc~~load_po4_restore~~CallsGraph proc~load_po4_restore load_PO4_restore nf90_close nf90_close proc~load_po4_restore->nf90_close nf90_strerror nf90_strerror proc~load_po4_restore->nf90_strerror nf90_inq_varid nf90_inq_varid proc~load_po4_restore->nf90_inq_varid nf90_open nf90_open proc~load_po4_restore->nf90_open nf90_get_var nf90_get_var proc~load_po4_restore->nf90_get_var Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~load_po4_restore~~CalledByGraph proc~load_po4_restore load_PO4_restore proc~load_tm_data load_TM_data proc~load_tm_data->proc~load_po4_restore Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/load_po4_restore.html"},{"title":"load_Martin_b_spatial – Fortran Matrix Lab","text":"public subroutine load_Martin_b_spatial() Loads spatially explicit Martin curve \"b\" data from netCDF Arguments None Calls proc~~load_martin_b_spatial~~CallsGraph proc~load_martin_b_spatial load_Martin_b_spatial nf90_close nf90_close proc~load_martin_b_spatial->nf90_close nf90_strerror nf90_strerror proc~load_martin_b_spatial->nf90_strerror nf90_inq_varid nf90_inq_varid proc~load_martin_b_spatial->nf90_inq_varid nf90_open nf90_open proc~load_martin_b_spatial->nf90_open nf90_get_var nf90_get_var proc~load_martin_b_spatial->nf90_get_var Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~load_martin_b_spatial~~CalledByGraph proc~load_martin_b_spatial load_Martin_b_spatial proc~load_tm_data load_TM_data proc~load_tm_data->proc~load_martin_b_spatial Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/load_martin_b_spatial.html"},{"title":"load_data_saving – Fortran Matrix Lab","text":"public subroutine load_data_saving() Loads data specifying timeseries and timeslice save points Arguments None Called by proc~~load_data_saving~~CalledByGraph proc~load_data_saving load_data_saving proc~initialise_model initialise_model proc~initialise_model->proc~load_data_saving program~fml fml program~fml->proc~initialise_model Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/load_data_saving.html"},{"title":"initialise_output – Fortran Matrix Lab","text":"public subroutine initialise_output() Initialises timeslice and timeseries output files creates output and restart directories if needed Arguments None Calls proc~~initialise_output~~CallsGraph proc~initialise_output initialise_output proc~initialise_timeslice_output initialise_timeslice_output proc~initialise_output->proc~initialise_timeslice_output proc~initialise_timeseries_output initialise_timeseries_output proc~initialise_output->proc~initialise_timeseries_output nf90_close nf90_close proc~initialise_timeslice_output->nf90_close nf90_create nf90_create proc~initialise_timeslice_output->nf90_create nf90_def_dim nf90_def_dim proc~initialise_timeslice_output->nf90_def_dim nf90_strerror nf90_strerror proc~initialise_timeslice_output->nf90_strerror nf90_enddef nf90_enddef proc~initialise_timeslice_output->nf90_enddef nf90_def_var nf90_def_var proc~initialise_timeslice_output->nf90_def_var Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~initialise_output~~CalledByGraph proc~initialise_output initialise_output proc~initialise_model initialise_model proc~initialise_model->proc~initialise_output program~fml fml program~fml->proc~initialise_model Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/initialise_output.html"},{"title":"initialise_timeseries_output – Fortran Matrix Lab","text":"public subroutine initialise_timeseries_output() Initialise timeseries output files Arguments None Called by proc~~initialise_timeseries_output~~CalledByGraph proc~initialise_timeseries_output initialise_timeseries_output proc~initialise_output initialise_output proc~initialise_output->proc~initialise_timeseries_output proc~initialise_model initialise_model proc~initialise_model->proc~initialise_output program~fml fml program~fml->proc~initialise_model Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/initialise_timeseries_output.html"},{"title":"write_timeseries_output – Fortran Matrix Lab","text":"public subroutine write_timeseries_output() Writes timeseries output to file Arguments None Calls proc~~write_timeseries_output~~CallsGraph proc~write_timeseries_output write_timeseries_output atm_int atm_int proc~write_timeseries_output->atm_int Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~write_timeseries_output~~CalledByGraph proc~write_timeseries_output write_timeseries_output proc~integrate_output integrate_output proc~integrate_output->proc~write_timeseries_output program~fml fml program~fml->proc~integrate_output Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/write_timeseries_output.html"},{"title":"initialise_timeslice_output – Fortran Matrix Lab","text":"public subroutine initialise_timeslice_output() Initialises netCDF output Arguments None Calls proc~~initialise_timeslice_output~~CallsGraph proc~initialise_timeslice_output initialise_timeslice_output nf90_close nf90_close proc~initialise_timeslice_output->nf90_close nf90_create nf90_create proc~initialise_timeslice_output->nf90_create nf90_def_dim nf90_def_dim proc~initialise_timeslice_output->nf90_def_dim nf90_strerror nf90_strerror proc~initialise_timeslice_output->nf90_strerror nf90_enddef nf90_enddef proc~initialise_timeslice_output->nf90_enddef nf90_def_var nf90_def_var proc~initialise_timeslice_output->nf90_def_var Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~initialise_timeslice_output~~CalledByGraph proc~initialise_timeslice_output initialise_timeslice_output proc~initialise_output initialise_output proc~initialise_output->proc~initialise_timeslice_output proc~initialise_model initialise_model proc~initialise_model->proc~initialise_output program~fml fml program~fml->proc~initialise_model Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/initialise_timeslice_output.html"},{"title":"write_output_netcdf – Fortran Matrix Lab","text":"public subroutine write_output_netcdf() writes netCDF output currently just for the last timestep!! Arguments None Calls proc~~write_output_netcdf~~CallsGraph proc~write_output_netcdf write_output_netcdf nf90_close nf90_close proc~write_output_netcdf->nf90_close nf90_strerror nf90_strerror proc~write_output_netcdf->nf90_strerror nf90_inq_varid nf90_inq_varid proc~write_output_netcdf->nf90_inq_varid nf90_open nf90_open proc~write_output_netcdf->nf90_open proc~v2f v2f proc~write_output_netcdf->proc~v2f nf90_put_var nf90_put_var proc~write_output_netcdf->nf90_put_var Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~write_output_netcdf~~CalledByGraph proc~write_output_netcdf write_output_netcdf proc~integrate_output integrate_output proc~integrate_output->proc~write_output_netcdf program~fml fml program~fml->proc~integrate_output Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/write_output_netcdf.html"},{"title":"write_restart – Fortran Matrix Lab","text":"public subroutine write_restart() Writes state variables to binary for restart Arguments None Called by proc~~write_restart~~CalledByGraph proc~write_restart write_restart program~fml fml program~fml->proc~write_restart Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/write_restart.html"},{"title":"load_restart – Fortran Matrix Lab","text":"public subroutine load_restart() Loads state variables from binary from restart experiment Arguments None Called by proc~~load_restart~~CalledByGraph proc~load_restart load_restart proc~initialise_model initialise_model proc~initialise_model->proc~load_restart program~fml fml program~fml->proc~initialise_model Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/load_restart.html"},{"title":"write_PO4_uptake – Fortran Matrix Lab","text":"public subroutine write_PO4_uptake() Write PO4 uptake to binary for fixed export subroutine Arguments None Called by proc~~write_po4_uptake~~CalledByGraph proc~write_po4_uptake write_PO4_uptake program~fml fml program~fml->proc~write_po4_uptake Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/write_po4_uptake.html"},{"title":"load_PO4_uptake – Fortran Matrix Lab","text":"public subroutine load_PO4_uptake() Load PO4 uptake binary for fixed uptake subroutine Arguments None Called by proc~~load_po4_uptake~~CalledByGraph proc~load_po4_uptake load_PO4_uptake proc~load_tm_data load_TM_data proc~load_tm_data->proc~load_po4_uptake Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/load_po4_uptake.html"},{"title":"PO4_uptake – Fortran Matrix Lab","text":"public subroutine PO4_uptake() Calculates PO4 uptake calculates biological uptake of PO4 updates other tracers via Redfield ratios calculates CaCO3 export via a rain-ratio Arguments None Calls proc~~po4_uptake~~CallsGraph proc~po4_uptake PO4_uptake bg_po4_uptake bg_po4_uptake proc~po4_uptake->bg_po4_uptake bg_po4_obs bg_po4_obs proc~po4_uptake->bg_po4_obs j j proc~po4_uptake->j Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~po4_uptake~~CalledByGraph proc~po4_uptake PO4_uptake program~fml fml program~fml->proc~po4_uptake Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/po4_uptake.html"},{"title":"DOP_remin – Fortran Matrix Lab","text":"public subroutine DOP_remin() Dissolved organic phosphorus remineralisation Arguments None Calls proc~~dop_remin~~CallsGraph proc~dop_remin DOP_remin j j proc~dop_remin->j Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~dop_remin~~CalledByGraph proc~dop_remin DOP_remin program~fml fml program~fml->proc~dop_remin Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/dop_remin.html"},{"title":"update_bgc – Fortran Matrix Lab","text":"public subroutine update_bgc() add biogeochemical sources/sinks to state arrays Arguments None Calls proc~~update_bgc~~CallsGraph proc~update_bgc update_bgc jatm jatm proc~update_bgc->jatm j j proc~update_bgc->j atm atm proc~update_bgc->atm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/update_bgc.html"},{"title":"calc_C_consts – Fortran Matrix Lab","text":"public subroutine calc_C_consts() Calculate carbonate system constants\n - uses DOE (1994) Arguments None Calls proc~~calc_c_consts~~CallsGraph proc~calc_c_consts calc_C_consts s_dt s_dt proc~calc_c_consts->s_dt t_dt t_dt proc~calc_c_consts->t_dt c_consts c_consts proc~calc_c_consts->c_consts Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~calc_c_consts~~CalledByGraph proc~calc_c_consts calc_C_consts program~fml fml program~fml->proc~calc_c_consts Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/calc_c_consts.html"},{"title":"calc_pCO2 – Fortran Matrix Lab","text":"public subroutine calc_pCO2() Solve carbonate system for pC02\n - M. Follows, T. Ito, S. Dutkiewicz (2006) in Ocean Modelling Arguments None Calls proc~~calc_pco2~~CallsGraph proc~calc_pco2 calc_pCO2 s_dt s_dt proc~calc_pco2->s_dt c c proc~calc_pco2->c c_consts c_consts proc~calc_pco2->c_consts Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~calc_pco2~~CalledByGraph proc~calc_pco2 calc_pCO2 program~fml fml program~fml->proc~calc_pco2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/calc_pco2.html"},{"title":"calc_gasexchange – Fortran Matrix Lab","text":"public subroutine calc_gasexchange() Calculate gas exchange between atmosphere and ocean\n - Orr et al., (2017) Geoscientific Model Development Arguments None Calls proc~~calc_gasexchange~~CallsGraph proc~calc_gasexchange calc_gasexchange jatm jatm proc~calc_gasexchange->jatm j j proc~calc_gasexchange->j sc_coeffs sc_coeffs proc~calc_gasexchange->sc_coeffs t_dt t_dt proc~calc_gasexchange->t_dt c c proc~calc_gasexchange->c s_dt s_dt proc~calc_gasexchange->s_dt sol_orr sol_orr proc~calc_gasexchange->sol_orr atm atm proc~calc_gasexchange->atm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~calc_gasexchange~~CalledByGraph proc~calc_gasexchange calc_gasexchange program~fml fml program~fml->proc~calc_gasexchange Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/calc_gasexchange.html"},{"title":"restore_atm_CO2 – Fortran Matrix Lab","text":"public subroutine restore_atm_CO2() Applies a restoring forcing for CO2 Arguments None Calls proc~~restore_atm_co2~~CallsGraph proc~restore_atm_co2 restore_atm_CO2 atm atm proc~restore_atm_co2->atm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~restore_atm_co2~~CalledByGraph proc~restore_atm_co2 restore_atm_CO2 program~fml fml program~fml->proc~restore_atm_co2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/restore_atm_co2.html"},{"title":"water_column – Fortran Matrix Lab","text":"public subroutine water_column() Implicit remineralisation of particulate organic carbon and CaCO3 Arguments None Calls proc~~water_column~~CallsGraph proc~water_column water_column j j proc~water_column->j proc~amul_transpose amul_transpose proc~water_column->proc~amul_transpose proc~amul amul proc~water_column->proc~amul Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~water_column~~CalledByGraph proc~water_column water_column program~fml fml program~fml->proc~water_column Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/water_column.html"},{"title":"load_namelist – Fortran Matrix Lab","text":"public subroutine load_namelist() Load user-defined namelist parameters Arguments None Called by proc~~load_namelist~~CalledByGraph proc~load_namelist load_namelist program~fml fml program~fml->proc~load_namelist Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/load_namelist.html"},{"title":"amul – Fortran Matrix Lab","text":"public function amul(A, vector) sparse matrix - vector multiplication (CSR format) adapted from SPARSEKIT (https://people.sc.fsu.edu/~jburkardt/f_src/sparsekit/sparsekit.html) Arguments Type Intent Optional Attributes Name type( sparse ), intent(in) :: A sparse matrix real, intent(in), dimension(tm_nbox) :: vector vector Return Value real,\n  dimension(tm_nbox) Called by proc~~amul~~CalledByGraph proc~amul amul proc~timestep_fml timestep_fml proc~timestep_fml->proc~amul proc~water_column water_column proc~water_column->proc~amul program~fml fml program~fml->proc~timestep_fml program~fml->proc~water_column Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/amul.html"},{"title":"amul_transpose – Fortran Matrix Lab","text":"public function amul_transpose(A, vector) transpose sparse matrix - vector multiplication (CSR format) adapted from SPARSEKIT (https://people.sc.fsu.edu/~jburkardt/f_src/sparsekit/sparsekit.html) Arguments Type Intent Optional Attributes Name type( sparse ), intent(in) :: A sparse matrix real, intent(in), dimension(tm_nbox) :: vector vector Return Value real,\n  dimension(tm_nbox) Called by proc~~amul_transpose~~CalledByGraph proc~amul_transpose amul_transpose proc~water_column water_column proc~water_column->proc~amul_transpose program~fml fml program~fml->proc~water_column Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/amul_transpose.html"},{"title":"amub_nnz – Fortran Matrix Lab","text":"public function amub_nnz(A, B) sparse matrix multiplication (CSR format): find nonzeros adapted from SPARSEKIT (https://people.sc.fsu.edu/~jburkardt/f_src/sparsekit/sparsekit.html) Arguments Type Intent Optional Attributes Name type( sparse ), intent(in) :: A sparse matrix type( sparse ), intent(in) :: B sparse matrix Return Value integer Called by proc~~amub_nnz~~CalledByGraph proc~amub_nnz amub_nnz proc~amub amub proc~amub->proc~amub_nnz proc~set_tm_timestep set_TM_timestep proc~set_tm_timestep->proc~amub proc~initialise_model initialise_model proc~initialise_model->proc~set_tm_timestep program~fml fml program~fml->proc~initialise_model Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/amub_nnz.html"},{"title":"initialise_model – Fortran Matrix Lab","text":"public subroutine initialise_model() Initialises FML model 1) sets up array indices 2) allocates arrays 3) loads in matrix data 4) initialises parameters 5) initialises arrays Arguments None Calls proc~~initialise_model~~CallsGraph proc~initialise_model initialise_model jatm jatm proc~initialise_model->jatm bg_po4_obs bg_po4_obs proc~initialise_model->bg_po4_obs tm_t tm_t proc~initialise_model->tm_t proc~load_restart load_restart proc~initialise_model->proc~load_restart proc~load_data_saving load_data_saving proc~initialise_model->proc~load_data_saving c c proc~initialise_model->c proc~create_aconv create_Aconv proc~initialise_model->proc~create_aconv bunsen_coeffs bunsen_coeffs proc~initialise_model->bunsen_coeffs t_dt t_dt proc~initialise_model->t_dt c_consts c_consts proc~initialise_model->c_consts proc~print_to_screen print_to_screen proc~initialise_model->proc~print_to_screen atm_int atm_int proc~initialise_model->atm_int proc~find_water_columns find_water_columns proc~initialise_model->proc~find_water_columns sc_coeffs sc_coeffs proc~initialise_model->sc_coeffs tm_s tm_s proc~initialise_model->tm_s bg_po4_uptake bg_po4_uptake proc~initialise_model->bg_po4_uptake s_dt s_dt proc~initialise_model->s_dt proc~load_tm_grid_data load_TM_grid_data proc~initialise_model->proc~load_tm_grid_data atm atm proc~initialise_model->atm proc~load_tm_bgc_data load_TM_bgc_data proc~initialise_model->proc~load_tm_bgc_data proc~initialise_output initialise_output proc~initialise_model->proc~initialise_output proc~set_tm_timestep set_TM_timestep proc~initialise_model->proc~set_tm_timestep proc~calc_seasonal_scaling calc_seasonal_scaling proc~initialise_model->proc~calc_seasonal_scaling sol_orr sol_orr proc~initialise_model->sol_orr proc~print_to_screen->atm nf90_close nf90_close proc~load_tm_grid_data->nf90_close nf90_strerror nf90_strerror proc~load_tm_grid_data->nf90_strerror nf90_inq_varid nf90_inq_varid proc~load_tm_grid_data->nf90_inq_varid nf90_open nf90_open proc~load_tm_grid_data->nf90_open nf90_get_var nf90_get_var proc~load_tm_grid_data->nf90_get_var proc~load_tm_bgc_data->nf90_close proc~load_tm_bgc_data->nf90_strerror proc~load_tm_bgc_data->nf90_inq_varid proc~load_tm_bgc_data->nf90_open proc~load_tm_bgc_data->nf90_get_var proc~initialise_timeseries_output initialise_timeseries_output proc~initialise_output->proc~initialise_timeseries_output proc~initialise_timeslice_output initialise_timeslice_output proc~initialise_output->proc~initialise_timeslice_output proc~amub amub proc~set_tm_timestep->proc~amub proc~initialise_timeslice_output->nf90_close proc~initialise_timeslice_output->nf90_strerror nf90_create nf90_create proc~initialise_timeslice_output->nf90_create nf90_def_dim nf90_def_dim proc~initialise_timeslice_output->nf90_def_dim nf90_enddef nf90_enddef proc~initialise_timeslice_output->nf90_enddef nf90_def_var nf90_def_var proc~initialise_timeslice_output->nf90_def_var proc~amub_nnz amub_nnz proc~amub->proc~amub_nnz Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~initialise_model~~CalledByGraph proc~initialise_model initialise_model program~fml fml program~fml->proc~initialise_model Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/initialise_model.html"},{"title":"set_TM_timestep – Fortran Matrix Lab","text":"public subroutine set_TM_timestep() Applies timestep to transport matrices Arguments None Calls proc~~set_tm_timestep~~CallsGraph proc~set_tm_timestep set_TM_timestep proc~amub amub proc~set_tm_timestep->proc~amub proc~amub_nnz amub_nnz proc~amub->proc~amub_nnz Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~set_tm_timestep~~CalledByGraph proc~set_tm_timestep set_TM_timestep proc~initialise_model initialise_model proc~initialise_model->proc~set_tm_timestep program~fml fml program~fml->proc~initialise_model Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/set_tm_timestep.html"},{"title":"calc_seasonal_scaling – Fortran Matrix Lab","text":"public subroutine calc_seasonal_scaling() Calculates indices for interpolating the seasonal transport matrices Arguments None Called by proc~~calc_seasonal_scaling~~CalledByGraph proc~calc_seasonal_scaling calc_seasonal_scaling proc~initialise_model initialise_model proc~initialise_model->proc~calc_seasonal_scaling program~fml fml program~fml->proc~initialise_model Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/calc_seasonal_scaling.html"},{"title":"timestep_fml – Fortran Matrix Lab","text":"public subroutine timestep_fml() Integrate model forward in time integrates model forward in time using fixed timesteps calculates \\mathbf{A_{imp}} * ( \\mathbf{A_{exp}}*\\mathbf{c}+\\mathbf{q}) where: \\mathbf{A_{imp}} - implicit matrix \\mathbf{A_{exp}} - explicit matrix \\mathbf{c} - state variable vector \\mathbf{q} - source/sink vector Arguments None Calls proc~~timestep_fml~~CallsGraph proc~timestep_fml timestep_fml jatm jatm proc~timestep_fml->jatm atm atm proc~timestep_fml->atm proc~amul amul proc~timestep_fml->proc~amul Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~timestep_fml~~CalledByGraph proc~timestep_fml timestep_fml program~fml fml program~fml->proc~timestep_fml Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/timestep_fml.html"},{"title":"amub – Fortran Matrix Lab","text":"public subroutine amub(A, B) sparse matrix multiplication A*B (CSR format) assumes square Matrix writes result to matrix A adapted from SPARSEKIT (https://people.sc.fsu.edu/~jburkardt/f_src/sparsekit/sparsekit.html) Arguments Type Intent Optional Attributes Name type( sparse ), intent(inout) :: A sparse matrix type( sparse ), intent(in) :: B sparse matrix Calls proc~~amub~~CallsGraph proc~amub amub proc~amub_nnz amub_nnz proc~amub->proc~amub_nnz Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~amub~~CalledByGraph proc~amub amub proc~set_tm_timestep set_TM_timestep proc~set_tm_timestep->proc~amub proc~initialise_model initialise_model proc~initialise_model->proc~set_tm_timestep program~fml fml program~fml->proc~initialise_model Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/amub.html"},{"title":"print_to_screen – Fortran Matrix Lab","text":"public subroutine print_to_screen(dum_t, dum_extra) Print output to screen during runtime Arguments Type Intent Optional Attributes Name integer :: dum_t timestep real :: dum_extra not used Calls proc~~print_to_screen~~CallsGraph proc~print_to_screen print_to_screen atm atm proc~print_to_screen->atm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~print_to_screen~~CalledByGraph proc~print_to_screen print_to_screen proc~initialise_model initialise_model proc~initialise_model->proc~print_to_screen program~fml fml program~fml->proc~print_to_screen program~fml->proc~initialise_model Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/print_to_screen.html"},{"title":"tm_vars_at_dt – Fortran Matrix Lab","text":"public subroutine tm_vars_at_dt() Linearly interpolate seaice, windstress, T, S at current timestep Arguments None Calls proc~~tm_vars_at_dt~~CallsGraph proc~tm_vars_at_dt tm_vars_at_dt tm_t tm_t proc~tm_vars_at_dt->tm_t tm_s tm_s proc~tm_vars_at_dt->tm_s Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~tm_vars_at_dt~~CalledByGraph proc~tm_vars_at_dt tm_vars_at_dt program~fml fml program~fml->proc~tm_vars_at_dt Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/tm_vars_at_dt.html"},{"title":"integrate_output – Fortran Matrix Lab","text":"public subroutine integrate_output(loc_t, loc_save_count, loc_dt_count) Average output and write to files if appropriate Arguments Type Intent Optional Attributes Name integer, intent(in) :: loc_t timestep integer, intent(inout) :: loc_save_count counter to keep track of number of save intervals integer, intent(in) :: loc_dt_count number of timesteps through averaging interval Calls proc~~integrate_output~~CallsGraph proc~integrate_output integrate_output proc~write_timeseries_output write_timeseries_output proc~integrate_output->proc~write_timeseries_output atm_int atm_int proc~integrate_output->atm_int atm atm proc~integrate_output->atm proc~write_output_netcdf write_output_netcdf proc~integrate_output->proc~write_output_netcdf proc~write_timeseries_output->atm_int nf90_close nf90_close proc~write_output_netcdf->nf90_close nf90_strerror nf90_strerror proc~write_output_netcdf->nf90_strerror nf90_inq_varid nf90_inq_varid proc~write_output_netcdf->nf90_inq_varid nf90_open nf90_open proc~write_output_netcdf->nf90_open proc~v2f v2f proc~write_output_netcdf->proc~v2f nf90_put_var nf90_put_var proc~write_output_netcdf->nf90_put_var Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~integrate_output~~CalledByGraph proc~integrate_output integrate_output program~fml fml program~fml->proc~integrate_output Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/integrate_output.html"},{"title":"find_water_columns – Fortran Matrix Lab","text":"public subroutine find_water_columns() Creates index of water columns in model grid Arguments None Called by proc~~find_water_columns~~CalledByGraph proc~find_water_columns find_water_columns proc~initialise_model initialise_model proc~initialise_model->proc~find_water_columns program~fml fml program~fml->proc~initialise_model Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/find_water_columns.html"},{"title":"create_Aconv – Fortran Matrix Lab","text":"public subroutine create_Aconv() Creates a sparse matrix that re-orders vectors to water-column order for remin subroutines Arguments None Called by proc~~create_aconv~~CalledByGraph proc~create_aconv create_Aconv proc~initialise_model initialise_model proc~initialise_model->proc~create_aconv program~fml fml program~fml->proc~initialise_model Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/create_aconv.html"},{"title":"io_module – Fortran Matrix Lab","text":"Subroutines to load and write data Uses fml_lib netcdf module~~io_module~~UsesGraph module~io_module io_module netcdf netcdf module~io_module->netcdf module~fml_lib fml_lib module~io_module->module~fml_lib Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~io_module~~UsedByGraph module~io_module io_module module~tm_module tm_module module~tm_module->module~io_module program~fml fml program~fml->module~io_module program~fml->module~tm_module module~bg_module bg_module program~fml->module~bg_module module~bg_module->module~tm_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions v2f Subroutines load_TM_data load_TM_netcdf load_TM_metadata load_TM_grid_data load_TM_bgc_data load_PO4_restore load_Martin_b_spatial load_data_saving initialise_output initialise_timeseries_output write_timeseries_output initialise_timeslice_output write_output_netcdf write_restart load_restart write_PO4_uptake load_PO4_uptake Functions public function v2f (vector) reorder vector into a 3D field Arguments Type Intent Optional Attributes Name real, dimension(tm_nbox) :: vector Return Value real,\n  dimension(NX,NY,NZ) Subroutines public subroutine load_TM_data () Arguments None public subroutine load_TM_netcdf (dum_filename, dum_A) Loads transport matrix data from netCDF files Arguments Type Intent Optional Attributes Name character(len=*) :: dum_filename netCDF filename type( sparse ) :: dum_A sparse matrix arrays public subroutine load_TM_metadata (dum_filename, dum_A) Loads transport matrix metadata from netCDF file Arguments Type Intent Optional Attributes Name character(len=*) :: dum_filename netCDF filename type( sparse ) :: dum_A sparse matrix arrays public subroutine load_TM_grid_data () Loads transport matrix grid data from netCDF file Arguments None public subroutine load_TM_bgc_data () Loads transport matrix biogeochemistry data from netCDF file Arguments None public subroutine load_PO4_restore () Loads [PO4] observations from netCDF file for nutrient restoring subroutine Arguments None public subroutine load_Martin_b_spatial () Loads spatially explicit Martin curve \"b\" data from netCDF Arguments None public subroutine load_data_saving () Loads data specifying timeseries and timeslice save points Arguments None public subroutine initialise_output () Initialises timeslice and timeseries output files Read more… Arguments None public subroutine initialise_timeseries_output () Initialise timeseries output files Arguments None public subroutine write_timeseries_output () Writes timeseries output to file Arguments None public subroutine initialise_timeslice_output () Initialises netCDF output Arguments None public subroutine write_output_netcdf () writes netCDF output Read more… Arguments None public subroutine write_restart () Writes state variables to binary for restart Arguments None public subroutine load_restart () Loads state variables from binary from restart experiment Arguments None public subroutine write_PO4_uptake () Write PO4 uptake to binary for fixed export subroutine Arguments None public subroutine load_PO4_uptake () Load PO4 uptake binary for fixed uptake subroutine Arguments None","tags":"","loc":"module/io_module.html"},{"title":"bg_module – Fortran Matrix Lab","text":"Subroutines related to biogeochemistry Uses fml_lib tm_module module~~bg_module~~UsesGraph module~bg_module bg_module module~tm_module tm_module module~bg_module->module~tm_module module~fml_lib fml_lib module~bg_module->module~fml_lib module~tm_module->module~fml_lib module~io_module io_module module~tm_module->module~io_module module~io_module->module~fml_lib netcdf netcdf module~io_module->netcdf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~bg_module~~UsedByGraph module~bg_module bg_module program~fml fml program~fml->module~bg_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines PO4_uptake DOP_remin update_bgc calc_C_consts calc_pCO2 calc_gasexchange restore_atm_CO2 water_column Subroutines public subroutine PO4_uptake () Calculates PO4 uptake Read more… Arguments None public subroutine DOP_remin () Dissolved organic phosphorus remineralisation Arguments None public subroutine update_bgc () add biogeochemical sources/sinks to state arrays Arguments None public subroutine calc_C_consts () Calculate carbonate system constants\n - uses DOE (1994) Arguments None public subroutine calc_pCO2 () Solve carbonate system for pC02\n - M. Follows, T. Ito, S. Dutkiewicz (2006) in Ocean Modelling Arguments None public subroutine calc_gasexchange () Calculate gas exchange between atmosphere and ocean\n - Orr et al., (2017) Geoscientific Model Development Arguments None public subroutine restore_atm_CO2 () Applies a restoring forcing for CO2 Arguments None public subroutine water_column () Implicit remineralisation of particulate organic carbon and CaCO3 Arguments None","tags":"","loc":"module/bg_module.html"},{"title":"fml_lib – Fortran Matrix Lab","text":"Namelist definitions of parameters definitions of key parameters in model default parameter values are set here parameter values can be overriden by the user loads user-defined parameters from experiment file Used by module~~fml_lib~~UsedByGraph module~fml_lib fml_lib module~bg_module bg_module module~bg_module->module~fml_lib module~tm_module tm_module module~bg_module->module~tm_module module~tm_module->module~fml_lib module~io_module io_module module~tm_module->module~io_module module~io_module->module~fml_lib program~fml fml program~fml->module~fml_lib program~fml->module~bg_module program~fml->module~tm_module program~fml->module~io_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables tm_Aexp_filename tm_Aimp_filename tm_native_dt tm_dt_scale tm_n_dt tm_nbox tm_PO4restore_filename tm_PO4uptake_filename tm_bgc_data_filename tm_grid_data_filename tm_seasonal tm_data_fileloc tm_save_PO4_uptake bg_uptake_tau bg_DOC_k bg_dt_ratio bg_DOC_frac bg_n_euphotic_lyrs bg_uptake_function bg_O_select bg_C_select bg_restore_atm_CO2 bg_restore_atm_CO2_target bg_gastransfer_a bg_rain_ratio bg_CaCO3_length_scale bg_martin_remin_b bg_martin_remin_spatial bg_martin_b_input_filename gen_n_tracers gen_runtime_years gen_save_timeseries_file gen_save_timeslice_file Aexp Aimp Aconv Apow1 tm_seaice_frac tm_windspeed tm_T tm_S tm_silica tm_area tm_vol tm_lon tm_lat tm_depth tm_depth_btm tm_i tm_j tm_k tm_wc seaice_dt wind_dt T_dt S_dt silica_dt bg_martin_b bg_PO4_obs bg_PO4_uptake tracers tracers_1 C C_consts J Jatm particles ATM export_save export_save_int diag tracers_int ATM_int t_int diag_int iSur tm_timeseries tm_timeslice gen_conv_d_yr bg_DOC_rfrac bg_PO4_init bg_DOC_init bg_DIC_init bg_ALK_init bg_dt ioPO4 ioDOP ioDIC ioALK ioCO2 ioCO3 ioH iopCO2 iK1 iK2 iKw iKp1 iKp2 iKp3 iKSi iKb iK0 iaO2 iaCO2 isPOP isCaCO3 tm_seasonal_scale tm_seasonal_rscale tm_seasonal_n1 tm_seasonal_n2 dt_count n_seasonal n_euphotic_boxes n_surface_boxes gen_restart_select gen_config_filename gen_restart_filename bg_C_to_P bg_N_to_P Sc_coeffs Bunsen_coeffs Sol_Orr conv_sec_yr n_ATM_tracers ATM_vol ATM_mol rho r_rho carbchem_tol tm_save_intra_freq timeseries_count timeslice_count NZ NY NX tm_dt Derived Types sparse Subroutines load_namelist Variables Type Visibility Attributes Name Initial character(len=100), public :: tm_Aexp_filename sparse matrix netCDF filename character(len=100), public :: tm_Aimp_filename sparse matrix netCDF filename real, public :: tm_native_dt = 1200.0 native timestep of transport matrix real, public :: tm_dt_scale = 1 multiplier to lengthen timestep integer, public :: tm_n_dt number of timesteps integer, public :: tm_nbox number of wet grid-boxes in matrix grid character(len=100), public :: tm_PO4restore_filename PO4 uptake forcing filenames character(len=100), public :: tm_PO4uptake_filename PO4 uptake forcing filenames character(len=100), public :: tm_bgc_data_filename = 'TMM_MIT_data.nc' filename of transport matrix metdata character(len=100), public :: tm_grid_data_filename = 'TMM_MIT_grid.nc' filename of transport matrix grid data logical, public :: tm_seasonal = .true. flag for seasonal transport matrices character(len=100), public :: tm_data_fileloc location of transport matrix files logical, public :: tm_save_PO4_uptake = .false. flag to save PO4 uptake for fixed uptake real, public :: bg_uptake_tau = 30.0 michaelis-menten uptake rate (mol kg &#94;{-1} yr &#94;{-1} ) real, public :: bg_DOC_k = 0.5 lifetime of dissolved organic matter (years) real, public :: bg_dt_ratio = 1.0 biogeochemistry timestep ratio real, public :: bg_DOC_frac = 0.66 fraction of biological uptake to dissolved organic carbon integer, public :: bg_n_euphotic_lyrs = 2 number of vertical layers considered euphotic zone character(len=100), public :: bg_uptake_function = 'restore' biological uptake function logical, public :: bg_O_select = .false. flag to select oxygen tracer logical, public :: bg_C_select = .false. flag to select carbon tracers (DIC + ALK) logical, public :: bg_restore_atm_CO2 = .false. flag to restore atmospheric CO2 real, public :: bg_restore_atm_CO2_target = 278.0 atmospheric CO2 value to restore to (mixing ratio) real, public :: bg_gastransfer_a = 6.97e-7 gas transfer velocity (m s &#94;{-1} ) real, public :: bg_rain_ratio CaCO3 remineralisation length scale (m) real, public :: bg_CaCO3_length_scale = 2100.0 CaCO3 remineralisation length scale (m) real, public :: bg_martin_remin_b = -0.858 Globally uniform Martin curve exponent (unitless) logical, public :: bg_martin_remin_spatial = .false. flag to select spatially explicit Martin curves character(len=100), public :: bg_martin_b_input_filename = '' filename of spatially explicit Martin curve exponents integer, public :: gen_n_tracers = 2 number of tracers integer, public :: gen_runtime_years = 1 runtime (years) character(len=100), public :: gen_save_timeseries_file filename containing savepoints for timeseries output character(len=100), public :: gen_save_timeslice_file filename containing save points for netCDF output type( sparse ), public :: Aexp Explicit transport matrix type( sparse ), public :: Aimp Implicit transport matrix type( sparse ), public :: Aconv sparse matrix to convert indices type( sparse ), public :: Apow1 temporary sparse matrix for multiplying Aimp real, public, dimension(:,:), allocatable :: tm_seaice_frac seaice fraction (fraction) real, public, dimension(:,:), allocatable :: tm_windspeed windspeed (m s &#94;{-1} real, public, dimension(:,:), allocatable :: tm_T temperature (deg C) real, public, dimension(:,:), allocatable :: tm_S salinity (PSU) real, public, dimension(:,:), allocatable :: tm_silica dissolved silica mol kg &#94;{-1} real, public, dimension(:), allocatable :: tm_area grid variables real, public, dimension(:), allocatable :: tm_vol grid variables real, public, dimension(:), allocatable :: tm_lon grid variables real, public, dimension(:), allocatable :: tm_lat grid variables real, public, dimension(:), allocatable :: tm_depth grid variables real, public, dimension(:), allocatable :: tm_depth_btm grid variables integer, public, dimension(:), allocatable :: tm_i vector indies integer, public, dimension(:), allocatable :: tm_j vector indies integer, public, dimension(:), allocatable :: tm_k vector indies integer, public, dimension(:), allocatable :: tm_wc vector indies real, public, dimension(:), allocatable :: seaice_dt interpolated seaice real, public, dimension(:), allocatable :: wind_dt interpolated windspeed real, public, dimension(:), allocatable :: T_dt interpolated temperature real, public, dimension(:), allocatable :: S_dt interpolated salinity real, public, dimension(:), allocatable :: silica_dt interpolated dissolved silica real, public, dimension(:), allocatable :: bg_martin_b spatially explicit martin exponent real, public, dimension(:,:), allocatable :: bg_PO4_obs PO4 observations real, public, dimension(:,:), allocatable :: bg_PO4_uptake fixed PO4 uptake (mol kg &#94;{-1} yr &#94;{-1} real, public, dimension(:,:), allocatable :: tracers state variable array real, public, dimension(:,:), allocatable :: tracers_1 state variable array real, public, dimension(:,:), allocatable :: C carbonate chemistry array real, public, dimension(:,:), allocatable :: C_consts carbonate chemistry constants real, public, dimension(:,:), allocatable :: J source/sink real, public, dimension(:,:), allocatable :: Jatm sorce/sink for atmosphere real, public, dimension(:,:), allocatable :: particles particle array real, public, dimension(:), allocatable :: ATM atmosphere array real, public, dimension(:), allocatable :: export_save array to save export real, public, dimension(:,:), allocatable :: export_save_int array to save integrated export real, public, dimension(:,:), allocatable :: diag array of diagnosed quantities real, public, dimension(:,:), allocatable :: tracers_int state variables integrated over time period real, public, dimension(:), allocatable :: ATM_int atmosphere integrated over time period real, public :: t_int = 0.0 ? real, public, dimension(:,:), allocatable :: diag_int diagnosed quantities integrated over time period integer, public, dimension(:), allocatable :: iSur indices of surface real, public, dimension(:), allocatable :: tm_timeseries saving timepoints real, public, dimension(:), allocatable :: tm_timeslice saving timepoints real, public :: gen_conv_d_yr = 365.25 convert days to years real, public :: bg_DOC_rfrac recipricol of bg_DOC_frac real, public :: bg_PO4_init = 0.00217 initial PO4 (mmol m-3 -> mol m-3) (Kriest et al., 2010) real, public :: bg_DOC_init = 0.0001*1E-03 inital DOP (mmol m-3 -> mol m-3) (Kriest et al., 2010) real, public :: bg_DIC_init = 2.299 initial DIC (mmol m-3 -> mol m-3) real, public :: bg_ALK_init = 2.420 initial Alkalinity (mmol m-3 -> mol m-3) real, public :: bg_dt biogeochemistry timestep (year) integer, public :: ioPO4 indices integer, public :: ioDOP indices integer, public :: ioDIC indices integer, public :: ioALK indices integer, public :: ioCO2 indices integer, public :: ioCO3 indices integer, public :: ioH indices integer, public :: iopCO2 indices integer, public :: iK1 indices integer, public :: iK2 indices integer, public :: iKw indices integer, public :: iKp1 indices integer, public :: iKp2 indices integer, public :: iKp3 indices integer, public :: iKSi indices integer, public :: iKb indices integer, public :: iK0 indices integer, public :: iaO2 indices integer, public :: iaCO2 indices integer, public :: isPOP indices integer, public :: isCaCO3 indices real, public, dimension(:), allocatable :: tm_seasonal_scale seasonal interpolation info real, public, dimension(:), allocatable :: tm_seasonal_rscale seasonal interpolation info integer, public, dimension(:), allocatable :: tm_seasonal_n1 seasonal interpolation info integer, public, dimension(:), allocatable :: tm_seasonal_n2 seasonal interpolation info integer, public :: dt_count counter for timesteps taken integer, public :: n_seasonal number of seasonal matrices integer, public :: n_euphotic_boxes number of vertical layers considered euphotic grid-boxes integer, public :: n_surface_boxes number of surface grid-boxes logical, public :: gen_restart_select = .false. flag to select restart character(len=100), public :: gen_config_filename character(len=100), public :: gen_restart_filename real, public :: bg_C_to_P = 116.0 Redfield C:P real, public :: bg_N_to_P = 16.0 Redfield N:P real, public, dimension(5,2) :: Sc_coeffs Schmidt number array for gas exchange real, public, dimension(6,2) :: Bunsen_coeffs Bunsen coefficients for gas exchange real, public, dimension(7,2) :: Sol_Orr solubility coefficients for gas exchange real, public :: conv_sec_yr = 60.0*60.0*24.0*365.25 convert seconds to years integer, public :: n_ATM_tracers real, public :: ATM_vol real, public :: ATM_mol real, public :: rho = 1024.5 average density real, public :: r_rho = 1.0/1024.5 recipricol of density real, public :: carbchem_tol = 0.01 tolerance for H+ convergence in carbonate chemistry subroutine real, public :: tm_save_intra_freq = 1.0 number of intra-year integration periods integer, public :: timeseries_count = 1 integer, public :: timeslice_count = 1 integer, public :: NZ = 15 integer, public :: NY = 64 integer, public :: NX = 128 real, public :: tm_dt Derived Types type, public :: sparse Components Type Visibility Attributes Name Initial real, public, allocatable, dimension(:,:) :: val_n all transport matrix nonzeros real, public, allocatable, dimension(:) :: val interpolated nonzeros integer(kind=4), public, allocatable, dimension(:) :: row row indices integer(kind=4), public, allocatable, dimension(:) :: col column indices integer, public :: nnz number of nonzeros integer, public :: nb matrix dimensions (assumed square) integer, public :: n_time number of matrices Subroutines public subroutine load_namelist () Load user-defined namelist parameters Arguments None","tags":"","loc":"module/fml_lib.html"},{"title":"tm_module – Fortran Matrix Lab","text":"Transport matrix related subroutines initialise model main timestepping subroutine various matrix operations Uses fml_lib io_module module~~tm_module~~UsesGraph module~tm_module tm_module module~io_module io_module module~tm_module->module~io_module module~fml_lib fml_lib module~tm_module->module~fml_lib module~io_module->module~fml_lib netcdf netcdf module~io_module->netcdf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~tm_module~~UsedByGraph module~tm_module tm_module module~bg_module bg_module module~bg_module->module~tm_module program~fml fml program~fml->module~tm_module program~fml->module~bg_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions amul amul_transpose amub_nnz Subroutines initialise_model set_TM_timestep calc_seasonal_scaling timestep_fml amub print_to_screen tm_vars_at_dt integrate_output find_water_columns create_Aconv Functions public function amul (A, vector) sparse matrix - vector multiplication (CSR format) Read more… Arguments Type Intent Optional Attributes Name type( sparse ), intent(in) :: A sparse matrix real, intent(in), dimension(tm_nbox) :: vector vector Return Value real,\n  dimension(tm_nbox) public function amul_transpose (A, vector) transpose sparse matrix - vector multiplication (CSR format) Read more… Arguments Type Intent Optional Attributes Name type( sparse ), intent(in) :: A sparse matrix real, intent(in), dimension(tm_nbox) :: vector vector Return Value real,\n  dimension(tm_nbox) public function amub_nnz (A, B) sparse matrix multiplication (CSR format): find nonzeros Read more… Arguments Type Intent Optional Attributes Name type( sparse ), intent(in) :: A sparse matrix type( sparse ), intent(in) :: B sparse matrix Return Value integer Subroutines public subroutine initialise_model () Initialises FML model Read more… Arguments None public subroutine set_TM_timestep () Applies timestep to transport matrices Arguments None public subroutine calc_seasonal_scaling () Calculates indices for interpolating the seasonal transport matrices Arguments None public subroutine timestep_fml () Integrate model forward in time Read more… Arguments None public subroutine amub (A, B) sparse matrix multiplication A*B (CSR format) Read more… Arguments Type Intent Optional Attributes Name type( sparse ), intent(inout) :: A sparse matrix type( sparse ), intent(in) :: B sparse matrix public subroutine print_to_screen (dum_t, dum_extra) Print output to screen during runtime Arguments Type Intent Optional Attributes Name integer :: dum_t timestep real :: dum_extra not used public subroutine tm_vars_at_dt () Linearly interpolate seaice, windstress, T, S at current timestep Arguments None public subroutine integrate_output (loc_t, loc_save_count, loc_dt_count) Average output and write to files if appropriate Arguments Type Intent Optional Attributes Name integer, intent(in) :: loc_t timestep integer, intent(inout) :: loc_save_count counter to keep track of number of save intervals integer, intent(in) :: loc_dt_count number of timesteps through averaging interval public subroutine find_water_columns () Creates index of water columns in model grid Arguments None public subroutine create_Aconv () Creates a sparse matrix that re-orders vectors to water-column order for remin subroutines Arguments None","tags":"","loc":"module/tm_module.html"},{"title":"fml – Fortran Matrix Lab","text":"Uses fml_lib tm_module bg_module io_module program~~fml~~UsesGraph program~fml fml module~tm_module tm_module program~fml->module~tm_module module~bg_module bg_module program~fml->module~bg_module module~io_module io_module program~fml->module~io_module module~fml_lib fml_lib program~fml->module~fml_lib module~tm_module->module~io_module module~tm_module->module~fml_lib module~bg_module->module~tm_module module~bg_module->module~fml_lib module~io_module->module~fml_lib netcdf netcdf module~io_module->netcdf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Main runtime\n - calls subroutines to set up model\n - sets up main timestep loop\n - calls biogeochemistry subroutines\n - calls subroutines to write model output Calls program~~fml~~CallsGraph program~fml fml jatm jatm program~fml->jatm proc~restore_atm_co2 restore_atm_CO2 program~fml->proc~restore_atm_co2 proc~timestep_fml timestep_fml program~fml->proc~timestep_fml proc~integrate_output integrate_output program~fml->proc~integrate_output j j program~fml->j proc~write_restart write_restart program~fml->proc~write_restart proc~write_po4_uptake write_PO4_uptake program~fml->proc~write_po4_uptake proc~calc_pco2 calc_pCO2 program~fml->proc~calc_pco2 proc~water_column water_column program~fml->proc~water_column proc~po4_uptake PO4_uptake program~fml->proc~po4_uptake proc~dop_remin DOP_remin program~fml->proc~dop_remin proc~initialise_model initialise_model program~fml->proc~initialise_model proc~print_to_screen print_to_screen program~fml->proc~print_to_screen proc~calc_c_consts calc_C_consts program~fml->proc~calc_c_consts proc~calc_gasexchange calc_gasexchange program~fml->proc~calc_gasexchange proc~tm_vars_at_dt tm_vars_at_dt program~fml->proc~tm_vars_at_dt proc~load_namelist load_namelist program~fml->proc~load_namelist atm atm proc~restore_atm_co2->atm proc~timestep_fml->jatm proc~amul amul proc~timestep_fml->proc~amul proc~timestep_fml->atm proc~write_output_netcdf write_output_netcdf proc~integrate_output->proc~write_output_netcdf atm_int atm_int proc~integrate_output->atm_int proc~integrate_output->atm proc~write_timeseries_output write_timeseries_output proc~integrate_output->proc~write_timeseries_output c c proc~calc_pco2->c c_consts c_consts proc~calc_pco2->c_consts s_dt s_dt proc~calc_pco2->s_dt proc~water_column->j proc~water_column->proc~amul proc~amul_transpose amul_transpose proc~water_column->proc~amul_transpose proc~po4_uptake->j bg_po4_obs bg_po4_obs proc~po4_uptake->bg_po4_obs bg_po4_uptake bg_po4_uptake proc~po4_uptake->bg_po4_uptake proc~dop_remin->j proc~initialise_model->jatm proc~initialise_model->proc~print_to_screen proc~initialise_model->bg_po4_obs tm_t tm_t proc~initialise_model->tm_t proc~load_restart load_restart proc~initialise_model->proc~load_restart proc~load_data_saving load_data_saving proc~initialise_model->proc~load_data_saving proc~initialise_model->c proc~create_aconv create_Aconv proc~initialise_model->proc~create_aconv bunsen_coeffs bunsen_coeffs proc~initialise_model->bunsen_coeffs t_dt t_dt proc~initialise_model->t_dt proc~initialise_model->c_consts proc~initialise_model->atm_int proc~find_water_columns find_water_columns proc~initialise_model->proc~find_water_columns sc_coeffs sc_coeffs proc~initialise_model->sc_coeffs tm_s tm_s proc~initialise_model->tm_s proc~initialise_model->bg_po4_uptake proc~initialise_model->s_dt proc~load_tm_grid_data load_TM_grid_data proc~initialise_model->proc~load_tm_grid_data proc~initialise_model->atm proc~load_tm_bgc_data load_TM_bgc_data proc~initialise_model->proc~load_tm_bgc_data proc~initialise_output initialise_output proc~initialise_model->proc~initialise_output proc~set_tm_timestep set_TM_timestep proc~initialise_model->proc~set_tm_timestep proc~calc_seasonal_scaling calc_seasonal_scaling proc~initialise_model->proc~calc_seasonal_scaling sol_orr sol_orr proc~initialise_model->sol_orr proc~print_to_screen->atm proc~calc_c_consts->t_dt proc~calc_c_consts->c_consts proc~calc_c_consts->s_dt proc~calc_gasexchange->jatm proc~calc_gasexchange->j proc~calc_gasexchange->c proc~calc_gasexchange->t_dt proc~calc_gasexchange->sc_coeffs proc~calc_gasexchange->s_dt proc~calc_gasexchange->atm proc~calc_gasexchange->sol_orr proc~tm_vars_at_dt->tm_t proc~tm_vars_at_dt->tm_s nf90_close nf90_close proc~write_output_netcdf->nf90_close nf90_strerror nf90_strerror proc~write_output_netcdf->nf90_strerror nf90_inq_varid nf90_inq_varid proc~write_output_netcdf->nf90_inq_varid nf90_open nf90_open proc~write_output_netcdf->nf90_open proc~v2f v2f proc~write_output_netcdf->proc~v2f nf90_put_var nf90_put_var proc~write_output_netcdf->nf90_put_var proc~load_tm_grid_data->nf90_close proc~load_tm_grid_data->nf90_strerror proc~load_tm_grid_data->nf90_inq_varid proc~load_tm_grid_data->nf90_open nf90_get_var nf90_get_var proc~load_tm_grid_data->nf90_get_var proc~load_tm_bgc_data->nf90_close proc~load_tm_bgc_data->nf90_strerror proc~load_tm_bgc_data->nf90_inq_varid proc~load_tm_bgc_data->nf90_open proc~load_tm_bgc_data->nf90_get_var proc~initialise_timeseries_output initialise_timeseries_output proc~initialise_output->proc~initialise_timeseries_output proc~initialise_timeslice_output initialise_timeslice_output proc~initialise_output->proc~initialise_timeslice_output proc~write_timeseries_output->atm_int proc~amub amub proc~set_tm_timestep->proc~amub proc~initialise_timeslice_output->nf90_close proc~initialise_timeslice_output->nf90_strerror nf90_create nf90_create proc~initialise_timeslice_output->nf90_create nf90_def_dim nf90_def_dim proc~initialise_timeslice_output->nf90_def_dim nf90_enddef nf90_enddef proc~initialise_timeslice_output->nf90_enddef nf90_def_var nf90_def_var proc~initialise_timeslice_output->nf90_def_var proc~amub_nnz amub_nnz proc~amub->proc~amub_nnz var panprogramfmlCallsGraph = svgPanZoom('#programfmlCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables n nn t p count save_count start finish sum_val start2 finish2 Variables Type Attributes Name Initial integer :: n various loop and counting indices integer :: nn various loop and counting indices integer :: t various loop and counting indices integer :: p various loop and counting indices integer :: count various loop and counting indices integer :: save_count various loop and counting indices real :: start variables to track elapsed real :: finish variables to track elapsed real :: sum_val variables to track elapsed real :: start2 variables to track elapsed real :: finish2 variables to track elapsed","tags":"","loc":"program/fml.html"}]}